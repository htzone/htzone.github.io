{"meta":{"title":"RedPig's Blog","subtitle":"","description":"","author":"RedPig","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"剖析String","slug":"剖析String","date":"2018-06-05T14:09:37.000Z","updated":"2020-04-12T15:14:35.944Z","comments":true,"path":"2018/06/05/剖析String/","link":"","permalink":"http://example.com/2018/06/05/%E5%89%96%E6%9E%90String/","excerpt":"","text":"基本用法Java中表示字符串的类是String，首先我们来介绍下Java中字符串的基本用法。 可以通过常量定义String变量 1String name = &quot;hello 世界！&quot;; 也可以通过new创建String 1String name = new String(&quot;hello 世界！&quot;); String可以直接使用+和+=运算符，如： 1234String name = &quot;hello&quot;;name += &quot;世界！&quot;;String test = &quot;你好！&quot;;System.out.println(name + test); 输出为：hello 世界！你好！ String类中还包括很多方法，以方便操作字符串，以下是一些常用的方法。 比如判断字符串是否为空，但这不包含为null的情况 1public boolean isEmpty() 判断一个字符串为null或为空字符串，我们一般这样自定义实现 123public boolean isBlank(String str) &#123; return str == null || str.isEmpty();&#125; 获取字符串长度 1public int length() 取子字符串 12public String substring(int beginIndex)public String substring(int beginIndex, int endIndex) 在字符串中查找字符或子字符串，返回第一个找到的索引位置，没找到返回-1 12public int indexOf(int ch)public int indexOf(String str) 从后面查找字符或子字符串，返回从后面数的第一个索引位置，没找到返回-1 12public int lastIndexOf(int ch)public int lastIndexOf(String str) 判断字符串中是否包含指定的字符序列。CharSequence是一个接口，表示一个字符序列，String也实现了CharSequence 1public boolean contains(CharSequence s) 判断字符串是否以给定子字符串开头 1public boolean startsWith(String prefix) 判断字符串是否以给定子字符串结尾 1public boolean endsWith(String suffix) 与其他字符串比较，看内容是否相同 1public boolean equals(Object anObject) 忽略大小写，与其他字符串进行比较，看内容是否相同 1public boolean equalsIgnoreCase(String anotherString) String也实现了Comparable接口，可以比较字符串大小 1public int compareTo(String anotherString) 还可以忽略大小写，进行大小比较 1public int compareToIgnoreCase(String str) 所有字符转换为大写字符，返回新字符串，原字符串不变 12public String toUpperCase()public String toUpperCase(Locale locale) 所有字符转换为小写字符，返回新字符串，原字符串不变 12public String toLowerCase()public String toLowerCase(Locale locale) 当你的程序在涉及国际化的情况下请务必指定locale，如：Locale.ENGLISH，不然在不同语言的机器上转换结果可能会不一致。 字符串连接，返回当前字符串和参数字符串合并后的字符串，原字符串不变 1public String concat(String str) 字符串替换，替换单个字符，返回新字符串，原字符串不变 1public String replace(char oldChar, char newChar) 字符串替换，替换字符序列，返回新字符串，原字符串不变 1public String replace(CharSequence target, CharSequence replacement) 删掉开头和结尾的空格，返回新字符串，原字符串不变 1public String trim() 分隔字符串，返回分隔后的子字符串数组，原字符串不变 1public String[] split(String regex) 注意这里参数是一个正则表达式，比如要按“.”号分割的话（“.”在正则表达式中有特殊含义），需按如下方式写 123String str = &quot;aa.bbb.cc&quot;;String[] arr = str.split(&quot;[.]&quot;);System.out.println(arr.length); 剖析String内部实现从调用者的角度理解了String的基本用法，下面我们进一步来理解String的内部。 封装字符数组 String类内部封装了一个字符数组表示字符串，实例变量定义为： 1private final char value[]; String有两个构造方法，可以根据char数组创建String 12public String(char value[])public String(char value[], int offset, int count) 需要说明的是，String会根据参数新创建一个数组，并拷贝内容，而不会直接用参数中的字符数组。 String中的大部分方法，内部也都是操作的这个字符数组。比如说： length()方法返回的就是这个数组的长度 substring()方法就是根据参数，调用构造方法String(char value[], int offset, int count)新建了一个字符串 indexOf查找字符或子字符串时就是在这个数组中进行查找 String中还有一些方法，与这个char数组有关： 1public char charAt(int index) 返回字符串对应的char数组 1public char[] toCharArray() 注意，这里返回的是一个拷贝后的数组，而不是原数组。 将char数组中指定范围的字符拷贝入目标数组指定位置 1public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) 编码转换 String内部是按UTF-16BE处理字符的，对BMP字符，使用一个char，两个字节，对于增补字符，使用两个char，四个字节。我们之前介绍过各种编码，不同编码可能用于不同的字符集，使用不同的字节数目，和不同的二进制表示。如何处理这些不同的编码呢？这些编码与Java内部表示之间如何相互转换呢？ Java使用Charset这个类表示各种编码，它有两个常用静态方法： 12public static Charset defaultCharset()public static Charset forName(String charsetName) 第一个方法返回系统的默认编码，比如，在我的电脑上，执行如下语句： 1System.out.println(Charset.defaultCharset().name()); // 输出为UTF-8 第二方法返回给定编码名称的Charset对象，与我们在第六节介绍的编码相对应，其charset名称可以是:US-ASCII, ISO-8859-1, windows-1252, GB2312, GBK, GB18030, Big5, UTF-8，比如： 1Charset charset = Charset.forName(&quot;GB18030&quot;); String类提供了如下方法，返回字符串按给定编码的字节表示： 123public byte[] getBytes()public byte[] getBytes(String charsetName)public byte[] getBytes(Charset charset) 第一个方法没有编码参数，使用系统默认编码，第二方法参数为编码名称，第三个为Charset。 String类有如下构造方法，可以根据字节和编码创建字符串，也就是说，根据给定编码的字节表示，创建Java的内部表示。 123456public String(byte bytes[])public String(byte bytes[], int offset, int length)public String(byte bytes[], int offset, int length, String charsetName)public String(byte bytes[], int offset, int length, Charset charset)public String(byte bytes[], String charsetName)public String(byte bytes[], Charset charset) 除了通过String中的方法进行编码转换，Charset类中也有一些方法进行编码/解码，这里就不介绍了。重要的是认识到，Java的内部表示与各种编码是不同的，但可以相互转换。 不可变性 与包装类类似，String类也是不可变类，即对象一旦创建，就没有办法修改了。String类也声明为了final，不能被继承，内部char数组value也是final的，初始化后就不能再变了。 String类中提供了很多看似修改的方法，其实是通过创建新的String对象来实现的，原来的String对象不会被修改。比如说，我们来看concat()方法的代码： 12345678910public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; int len = value.length; char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len); return new String(buf, true);&#125; 通过Arrays.copyOf方法创建了一块新的字符数组，拷贝原内容，然后通过new创建了一个新的String。 与包装类类似，定义为不可变类，程序可以更为简单、安全、容易理解。但如果频繁修改字符串，而每次修改都新建一个字符串，性能太低，这时，应该考虑Java中的另两个类StringBuilder和StringBuffer。 常量字符串 Java中的字符串常量是非常特殊的，除了可以直接赋值给String变量外，它自己就像一个String类型的对象一样，可以直接调用String的各种方法。我们来看代码： 123System.out.println(&quot;hello world&quot;.length());System.out.println(&quot;老hello&quot;.contains(&quot;world&quot;));System.out.println(&quot;hello&quot;.indexOf(&quot;el&quot;)); 实际上，这些常量就是String类型的对象，在内存中，它们被放在一个共享的地方，这个地方称为字符串常量池，它保存所有的常量字符串，每个常量只会保存一份，被所有使用者共享。当通过常量的形式使用一个字符串的时候，使用的就是常量池中的那个对应的String类型的对象。 比如说，我们来看代码： 1234String nihao = new String(new char[]&#123;&#x27;你&#x27;,&#x27;好&#x27;,&#x27;世&#x27;,&#x27;界&#x27;&#125;);String name1 = nihao;String name2 = nihao;System.out.println(name1==name2); 实际上只有一个String对象，三个变量都指向这个对象，name1==name2也就不言而喻了。 需要注意的是，如果不是通过常量直接赋值，而是通过new创建的，==就不会返回true了，看下面代码： 123String name1 = new String(&quot;你好世界&quot;);String name2 = new String(&quot;你好世界&quot;);System.out.println(name1==name2); 输出为false，为什么呢？上面代码类似于： 123String name1 = new String(nihao);String name2 = new String(nihao);System.out.println(name1==name2); String类中以String为参数的构造方法代码如下： 1234public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125; hash是String类中另一个实例变量，表示缓存的hashCode值，我们待会介绍。可以看出, name1和name2指向两个不同的String对象，只是这两个对象内部的value值指向相同的char数组。 所以，name1==name2是不成立的，但name1.equals(name2)是true。 hashCode 我们刚刚提到hash这个实例变量，它的定义如下： 1private int hash; // Default to 0 它缓存了hashCode()方法的值，也就是说，第一次调用hashCode()的时候，会把结果保存在hash这个变量中，以后再调用就直接返回保存的值。 我们来看下String类的hashCode方法，代码如下： 123456789101112public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; 如果缓存的hash不为0，就直接返回了，否则根据字符数组中的内容计算hash，计算方法是：s[0]*31^(n-1) + s[1]*31^(n-2) + … + s[n-1] s表示字符串，s[0]表示第一个字符，n表示字符串长度，s[0]*31^(n-1)表示31的n-1次方再乘以第一个字符的值。 为什么要用这个计算方法呢？这个式子中，hash值与每个字符的值有关，每个位置乘以不同的值，hash值与每个字符的位置也有关。使用31大概是因为两个原因，一方面可以产生更分散的散列，即不同字符串hash值也一般不同，另一方面计算效率比较高，31h与32h-h即 (h&lt;&lt;5)-h等价，可以用更高效率的移位和减法操作代替乘法操作。 在Java中，普遍采用以上思路来实现hashCode。 正则表达式 String类中，有一些方法接受的不是普通的字符串参数，而是正则表达式，什么是正则表达式呢？它可以理解为一个字符串，但表达的是一个规则，一般用于文本的匹配、查找、替换等，正则表达式有着丰富和强大的功能，是一个比较庞大的话题，我们可能会在后续章节单独介绍。 Java中有专门的类如Pattern和Matcher用于正则表达式，但对于简单的情况，String类提供了更为简洁的操作，String中接受正则表达式的方法有： 分隔字符串 1public String[] split(String regex) 检查是否匹配 1public boolean matches(String regex) 字符串替换 12public String replaceFirst(String regex, String replacement)public String replaceAll(String regex, String replacement) 小结本节，我们介绍了String类，介绍了其基本用法，内部实现，编码转换，分析了其不可变性，常量字符串，以及hashCode的实现。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Char的本质是什么","slug":"Char的本质是什么","date":"2018-05-11T14:09:37.000Z","updated":"2020-04-02T14:39:42.023Z","comments":true,"path":"2018/05/11/Char的本质是什么/","link":"","permalink":"http://example.com/2018/05/11/Char%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88/","excerpt":"","text":"本节讨论在Java中进行字符处理的基础 - char，Java中还有Character, String, StringBuffer, StringBuilder等类进行文本处理，他们的基础都是char，我们在后续文章中介绍这些类。 char的本质char看上去是很简单的，正如我们之前所说，char用于表示一个字符，这个字符可以是中文字符，也可以是英文字符。赋值时把常量字符用单引号括起来，例如： 12char c = &#x27;A&#x27;;char z = &#x27;中&#x27;; 但为什么字符类型也可以进行算术运算和比较？char的本质到底是什么呢？ 在 Java内部进行字符处理时，采用的都是Unicode，具体编码格式是UTF-16BE。UTF-16使用两个或四个字节表示一个字符，Unicode编号范围在65536以内的占两个字节，超出范围的占四个字节，BE (Big Endian)就是先输出高位字节，再输出低位字节，这与整数的内存表示是一致的。 因此，char本质上是一个固定占用两个字节的无符号正整数，这个正整数对应于Unicode编号，用于表示那个Unicode编号对应的字符。 由于固定占用两个字节，char只能表示Unicode编号在65536以内的字符，而不能表示超出范围的字符。 那超出范围的字符怎么表示呢？使用两个char。类String有一些相关的方法，我们后续会介绍。 在这个认识的基础上，我们再来看下char的一些行为，就比较容易理解了。 char的赋值 char有多种赋值方式： 12345char c = &#x27;A&#x27; // 1char c = &#x27;马&#x27; // 2char c = 39532 // 3char c = 0x9a6c // 4char c = &#x27;\\u9a6c&#x27; // 5 第1种赋值方式是最常见的，将一个能用Ascii码表示的字符赋给一个字符变量。 第 2种也很常见，但这里是个中文字符，需要注意的是，直接写字符常量的时候应该注意文件的编码，比如说，GBK编码的代码文件按UTF-8打开，字符会变成乱码，赋值的时候是按当前的编码解读方式，将这个字符形式对应的Unicode编号值赋给变量，’马’对应的Unicode编号是39532，所以第2种赋值和第3种是一样的。 第3种是直接将十进制的常量赋给字符。 第4种是将16进制常量赋给字符。 第5种是按Unicode字符形式。 以上，2，3，4，5都是一样的，本质都是将Unicode编号39532赋给了字符。 char的运算由于char本质上是一个整数，所以可以进行整数可以进行的一些运算，在进行运算时会被看做int，但由于char占两个字节，运算结果不能直接赋值给char类型，需要进行强制类型转换，这和byte, short参与整数运算是类似的。 char类型的比较就是其Unicode编号的比较。 char 的加减运算就是按其Unicode编号进行运算，一般对字符做加减运算没什么意义，但Ascii码字符是有意义的。比如大小写转换，大写A-Z的编号是 65-90，小写a-z的编号是97-122，正好相差32，所以大写转小写只需加32，而小写转大写只需减32。加减运算的另一个应用是加密和解密，将 字符进行某种可逆的数学运算可以做加解密。 char的位运算可以看做就是对应整数的位运算，只是它是无符号数，也就是说，有符号右移&gt;&gt;和无符号右移&gt;&gt;&gt;的结果是一样的。 char的二进制 既然char本质上是整数，查看char的二进制表示，同样可以用Integer的方法，如下所示： 12char c = &#x27;马&#x27;;System.out.println(Integer.toBinaryString(c)); 输出为 1001101001101100 小结本节介绍了char的本质，它固定占用两个字节，实际上是一个整数，表示字符的Unicode编号，不在65536编号内的字符一个char表示不了，需要用两个char。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"编码与乱码","slug":"编码与乱码","date":"2018-05-06T14:09:37.000Z","updated":"2020-04-01T15:39:15.014Z","comments":true,"path":"2018/05/06/编码与乱码/","link":"","permalink":"http://example.com/2018/05/06/%E7%BC%96%E7%A0%81%E4%B8%8E%E4%B9%B1%E7%A0%81/","excerpt":"","text":"编码ASCII世界上虽然有各种各样的字符，但计算机发明之初没有考虑那么多，基本上只考虑了美国的需求，美国大概只需要128个字符，美国就规定了这128个字符的二进制表示方法。这个方法是一个标准，称为ASCII编码，全称是American Standard Code for Information Interchange，美国信息互换标准代码。 128个字符用7个位刚好可以表示，计算机存储的最小单位是byte，即8位，ASCII码中最高位设置为0，用剩下的7位表示字符。这7位可以看做数字0到127，ASCII码规定了从0到127个，每个数字代表什么含义。 数字32到126表示的这些字符都是可打印字符，0到31和127表示一些不可以打印的字符，这些字符一般用于控制目的，这些字符中大部分都是不常用的，下表列出了其中相对常用的字符。 数字 缩写 解释 转义字符 0 NUL 空字符 \\0 8 BS 退格 \\b 9 HT 水平制表符 \\t 10 LF 换行符 \\n 13 CR 回车键 \\r 27 ESC 换码 127 DEL 删除 Ascii 码对美国是够用了，但对别的国家而言却是不够的，于是，各个国家的各种计算机厂商就发明了各种各种的编码方式以表示自己国家的字符，为了保持与Ascii 码的兼容性，一般都是将最高位设置为1。也就是说，当最高位为0时，表示Ascii码，当为1时就是各个国家自己的字符。 在这些扩展的编码中，在西欧国家中流行的是ISO 8859-1和Windows-1252，在中国是GB2312，GBK，GB18030和Big5，我们逐个来看下这些编码。 ISO 8859-1ISO 8859-1又称Latin-1，它也是使用一个字节表示一个字符，其中0到127与Ascii一样，128到255规定了不同的含义。 在128到255中，128到159表示一些控制字符，这些字符也不常用，就不介绍了。 Windows-1252ISO 8859-1虽然号称是标准，用于西欧国家，但它连欧元(€) 这个符号都没有，因为欧元比较晚，而标准比较早。实际使用中更为广泛的是Windows-1252编码，这个编码与ISO8859-1基本是一样的，区别只在于数字128到159，Windows-1252使用其中的一些数字表示可打印字符。 ISO 8859-1基本已被Windows-1252取代，在很多应用程序中，即使文件声明它采用的是ISO 8859-1编码，解析的时候依然被当做Windows-1252编码。 HTML5 甚至明确规定，如果文件声明的是ISO 8859-1编码，它应该被看做Windows-1252编码。为什么要这样呢？因为大部分人搞不清楚ISO 8859-1和Windows-1252的区别，当他说ISO 8859-1的时候，其实他实际指的是Windows-1252，所以标准干脆就这么强制了。 GB2312美国和西欧字符用一个字节就够了，但中文显然是不够的。中文第一个标准是GB2312。 GB2312标准主要针对的是简体中文常见字符，包括约7000个汉字，不包括一些罕用词，不包括繁体字。 GB2312固定使用两个字节表示汉字，在这两个字节中，最高位都是1，如果是0，就认为是Ascii字符。在这两个字节中，其中高位字节范围是0xA1-0xF7，低位字节范围是0xA1-0xFE。 GBKGBK建立在GB2312的基础上，向下兼容GB2312，也就是说，GB2312编码的字符和二进制表示，在GBK编码里是完全一样的。 GBK增加了一万四千多个汉字，共计约21000汉字，其中包括繁体字。 GBK同样使用固定的两个字节表示，其中高位字节范围是0x81-0xFE，低位字节范围是0x40-0x7E和0x80-0xFE。 需要注意的是，低位字节是从0x40也就是64开始的，也就是说，低位字节最高位可能为0。那怎么知道它是汉字的一部分，还是一个Ascii字符呢？ 其实很简单，因为汉字是用固定两个字节表示的，在解析二进制流的时候，如果第一个字节的最高位为1，那么就将下一个字节读进来一起解析为一个汉字，而不用考虑它的最高位，解析完后，跳到第三个字节继续解析。 GB18030GB18030向下兼容GBK，增加了五万五千多个字符，共七万六千多个字符。包括了很多少数民族字符，以及中日韩统一字符。 用两个字节已经表示不了GB18030中的所有字符，GB18030使用变长编码，有的字符是两个字节，有的是四个字节。 在两字节编码中，字节表示范围与GBK一样。在四字节编码中，第一个字节的值从0x81到0xFE，第二个字节的值从0x30到0x39，第三个字节的值从0x81到0xFE，第四个字节的值从0x30到0x39。 解析二进制时，如何知道是两个字节还是四个字节表示一个字符呢？看第二个字节的范围，如果是0x30到0x39就是四个字节表示，因为两个字节编码中第二字节都比这个大。 Big5Big5是针对繁体中文的，广泛用于台湾香港等地。 Big5包括1万3千多个繁体字，和GB2312类似，一个字符同样固定使用两个字节表示。在这两个字节中，高位字节范围是0x81-0xFE，低位字节范围是0x40-0x7E和0xA1-0xFE。 编码总结我们简单总结一下上面的内容。 Ascii码是基础，一个字节表示，最高位设为0，其他7位表示128个字符。其他编码都是兼容Ascii的，最高位使用1来进行区分。 西欧主要使用Windows-1252，使用一个字节，增加了额外128个字符。 中文大陆地区的三个主要编码GB2312，GBK，GB18030，有时间先后关系，表示的字符数越来越多，且后面的兼容前面的，GB2312和GBK都是用两个字节表示，而GB18030则使用两个或四个字节表示。 香港台湾地区的主要编码是Big5。 如果文本里的字符都是Ascii码字符，那么采用以上所说的任一编码方式都是一一样的。 但如果有高位为1的字符，除了GB2312/GBK/GB18030外，其他编码都是不兼容的，比如，Windows-1252和中文的各种编码是不兼容的，即使Big5和GB18030都能表示繁体字，其表示方式也是不一样的，而这就会出现所谓的乱码。 为什么会出现乱码一个法国人，采用Windows-1252编码写了个文件，发送给了一个中国人，中国人使用GB18030来解析这个字符，看到的就是乱码，我们举个例子： 法 国人发送的是 “Pékin”，Windows-1252的二进制是（采用16进制）：50 E9 6B 69 6E，第二个字节E9对应é，其他都是Ascii码，中国人收到的也是这个二进制，但是他把它看做成了GB18030编码，GB18030中E9 6B对应的是字符”閗i”，于是他看到的就是：”P閗in”，这看来就是一个乱码。 反之也是一样的，一个GB18030编码的文件如果被看做Windows-1252也是乱码。 这 种情况下，之所以看起来是乱码，是因为看待或者说解析数据的方式错了。纠正的方式，只要使用正确的编码方式进行解读就可以了。很多文件编辑器，如 EditPlus, NotePad++, UltraEdit都有切换查看编码方式的功能，浏览器也都有切换查看编码方式的功能，如Firefox，在菜单 “查看”-&gt;”文字编码”中。 切换查看编码的方式，并没有改变数据的二进制本身，而只是改变了解析数据的方式，从而改变了数据看起来的样子。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"小数计算为什么不精确","slug":"小数计算为什么不精确","date":"2018-05-02T14:09:37.000Z","updated":"2020-04-01T15:19:25.032Z","comments":true,"path":"2018/05/02/小数计算为什么不精确/","link":"","permalink":"http://example.com/2018/05/02/%E5%B0%8F%E6%95%B0%E8%AE%A1%E7%AE%97%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%B2%BE%E7%A1%AE/","excerpt":"","text":"违反直觉计算机之所以叫”计算”机就是因为发明它主要是用来计算的，”计算”当然是它的特长，在大家的印象中，计算一定是非常准确的。但实际上，即使在一些非常基本的小数运算中，计算的结果也是不精确的。 比如： 12float f = 0.1f*0.1f;System.out.println(f); 这个结果看上去，不言而喻，应该是0.01，但实际上，屏幕输出却是0.010000001，后面多了个1。 看上去这么简单的运算，计算机怎么会出错了呢？ 为什么会出错呢？实际上，不是运算本身会出错，而是计算机根本就不能精确的表示很多数，比如0.1这个数。 计算机是用一种二进制格式存储小数的，这个二进制格式不能精确表示0.1，它只能表示一个非常接近0.1但又不等于0.1的一个数。 数字都不能精确表示，在不精确数字上的运算结果不精确也就不足为奇了。 0.1怎么会不能精确表示呢？在十进制的世界里是可以的，但在二进制的世界里不行。在说二进制之前，我们先来看下熟悉的十进制。 实际上，十进制也只能表示那些可以表述为10的多少次方和的数，比如12.345，实际上表示的：110+21+30.1+40.01+5*0.001，与整数的表示类似，小数点后面的每个位置也都有一个位权，从左到右，依次为 0.1,0.01,0.001,…即10^(-1), 10^(-2), 10^(-3)。 很多数，十进制也是不能精确表示的，比如1/3, 保留三位小数的话，十进制表示是0.333，但无论后面保留多少位小数，都是不精确的，用0.333进行运算，比如乘以3，期望结果是1，但实际上却是0.999。 二进制是类似的，但二进制只能表示哪些可以表述为2的多少次方和的数，来看下2的次方的一些例子： 2的次方 十进制 2^(-1) 0.5 2^(-2) 0.25 2^(-3) 0.125 2^(-4) 0.0625 因此只可以精确表示为2的某次方之和的数，其他数则不能精确表示。 为什么一定要用二进制呢？为什么就不能用我们熟悉的十进制呢？在最最底层，计算机使用的电子元器件只能表示两个状态，通常是低压和高压，对应0和1，使用二进制容易基于这些电子器件构建硬件设备和进行运算。如果非要使用十进制，则这些硬件就会复杂很多，并且效率低下。 为什么有的小数计算是准确的？如果你编写程序进行试验，你会发现有的计算结果是准确的。比如，我用Java写： 12System.out.println(0.1f + 0.1f);System.out.println(0.1f * 0.1f); 第一行输出0.2，第二行输出0.010000001。按照上面的说法，第一行的结果应该也不对啊？ 其实，这只是Java语言给我们造成的假象，计算结果其实也是不精确的，但是由于结果和0.2足够接近，在输出的时候，Java选择了输出0.2这个看上去非常精简的数字，而不是一个中间有很多0的小数。 在误差足够小的时候，结果看上去是精确的，但不精确才是常态。 怎么处理计算不精确计算不精确，怎么办呢？ 减小精度。大部分情况下，我们不需要那么高的精度，可以四舍五入，或者在输出的时候只保留固定个数的小数位。 进行转换。如果真的需要比较高的精度，可以将小数转化为整数进行运算，运算结束后再转化为小数。 使用十进制的数据类型。这个没有统一的规范，在Java中是用BigDecimal，运算更准确，但效率比较低。 小结小数计算为什么会出错呢？ 理由就是：很多小数计算机中不能精确表示，通常只可以精确表示为2的某次方之和的数，其他数则不能精确表示。计算机的基本思维是二进制的，所以，意料之外，情理之中吧。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"整数的二进制表示和位运算","slug":"整数的二进制表示和位运算","date":"2018-04-08T14:09:37.000Z","updated":"2020-04-01T14:56:28.831Z","comments":true,"path":"2018/04/08/整数的二进制表示和位运算/","link":"","permalink":"http://example.com/2018/04/08/%E6%95%B4%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"上节我们提到正整数相乘的结果居然出现了负数，要理解这个行为，我们需要看下整数在计算机内部的二进制表示。 十进制要理解二进制，我们先来看下熟悉的十进制。十进制是如此的熟悉，我们可能已忽略了它的含义。比如123，我们不假思索就知道它的值是多少。 但其实123表示的1*(10^2) + 2*(10^1) + 3*(10^0)，(10^2表示10的二次方)，它表示的是各个位置数字含义之和，每个位置的数字含义与位置有关，从右向左，第一位乘以10的0次方， 即1，第二位乘以10的1次方，即10，第三位乘以10的2次方，即100，依次类推。 换句话说，每个位置都有一个位权，从右到左，第一位为1，然后依次乘以10，即第二位为10，第三位为100，依次类推。 二进制正整数的二进制表示正整数的二进制表示与此类似， 只是在十进制中，每个位置可以有10个数字，从0到9，但在二进制中，每个位置只能是0或1。位权的概念是类似的，从右到左，第一位为1，然后依次乘以2，即第二位为2，第三位为4，依次类推。 看一些数字的例子吧 二进制 十进制 10 2 11 3 111 7 1010 10 负整数的二进制表示十进制的负数表示就是在前面加一个负数符号-，例如-123。但二进制如何表示负数呢？ 其实概念是类似的，二进制使用最高位表示符号位，用1表示负数，用0表示正数。 但哪个是最高位呢？整数有四种类型，byte/short/int/long，分别占1/2/4/8个字节，即分别占8/16/32/64位，每种类型的符号位都是其最左边的一位。 为方便举例，下面假定类型是byte，即从右到左的第8位表示符号位。 但负数表示不是简单的将最高位变为1，比如说： byte a = -1，如果只是将最高位变为1，二进制应该是10000001，但实际上，它应该是11111111。 byte a=-127，如果只是将最高位变为1，二进制应该是11111111，但实际上，它却应该是10000001。 和我们的直觉正好相反，这是什么表示法？这种表示法称为补码表示法，而符合我们直觉的表示称为原码表示法，补码表示就是在原码表示的基础上取反然后加1。取反就是将0变为1，1变为0。 负数的二进制表示就是对应的正数的补码表示，比如说： -1：1的原码表示是00000001，取反是11111110，然后再加1，就是11111111。 -2：2的原码表示是00000010，取反是11111101，然后再加1，就是11111110。 -127：127的原码表示是01111111，取反是10000000，然后再加1，就是10000001。 给定一个负数二进制表示，要想知道它的十进制值，可以采用相同的补码运算。比如：10010010，首先取反，变为01101101，然后加1，结果为01101110，它的十进制值为110，所以原值就是-110。直觉上，应该是先减1，然后再取反，但计算机只能做加法，而补码的一个良好特性就是，对负数的补码表示做补码运算就可以得到其对应整数的原码，正如十进制运算中负负得正一样。 byte类型，正数最大表示是01111111，即127，负数最小表示（绝对值最大）是10000000，即-128，表示范围就是 -128到127。其他类型的整数也类似，负数能多表示一个数。 负整数为什么采用补码呢？ 负整数为什么要采用这种奇怪的表示形式呢？原因是：只有这种形式，计算机才能实现正确的加减法。 计算机其实只能做加法，1-1其实是1+(-1)。如果用原码表示，计算结果是不对的。比如说： 1234 1 -&gt; 00000001-1 -&gt; 10000001+ -------------------2 -&gt; 10000010 用符合直觉的原码表示，1-1的结果是-2。 如果是补码表示： 1234 1 -&gt; 00000001-1 -&gt; 11111111+ ------------------ 0 -&gt; 00000000 结果是正确的。 再比如，5-3： 1234 5 -&gt; 00000101-3 -&gt; 11111101+ ------------------ 2 -&gt; 00000010 结果也是正确的。 就是这样的，看上去可能比较奇怪和难以理解，但这种表示其实是非常严谨和正确的，是不是很奇妙？ 理解了二进制加减法，我们就能理解为什么正数的运算结果可能出现负数了。当计算结果超出表示范围的时候，最高位往往是1，然后就会被看做负数。比如说，127+1： 1234127 -&gt; 011111111 -&gt; 00000001+ -------------------128 -&gt; 10000000 计算结果超出了byte的表示范围，会被看做-128。 十六进制二进制写起来太长，为了简化写法，可以将四个二进制位简化为一个0到15的数，10到15用字符A到F表示，这种表示方法称为16进制，如下所示： 二进制 十进制 十六进制 1010 10 A 1011 11 B 1100 12 C 1101 13 D 1110 14 E 1111 15 F 可以用16进制直接写常量数字，在数字前面加0x即可。比如10进制的123，用16进制表示是0x7B，即123 = 7*16+11。给整数赋值或者进行运算的时候，都可以直接使用16进制，比如： 1int a = 0x7B; Java中不支持直接写二进制常量，比如，想写二进制形式的11001，Java中不能直接写，可以在前面补0，补足8位，为00011001，然后用16进制表示，即 0x19。 位运算位运算是将数据看做二进制，进行位级别的操作，Java不能单独表示一个位，但是可以用byte表示8位，可以用16进制写二进制常量。比如： 0010表示成16进制是 0x2, 110110表示成16进制是 0x36。 位运算有移位运算和逻辑运算。 移位有： 左移：操作符为&lt;&lt;，向左移动，右边的低位补0，高位的就舍弃掉了，将二进制看做整数，左移1位就相当于乘以2。 无符号右移：操作符为&gt;&gt;&gt;，向右移动，右边的舍弃掉，左边补0。 有符号右移：操作符为&gt;&gt;，向右移动，右边的舍弃掉，左边补什么取决于原来最高位是什么，原来是1就补1，原来是0就补0，将二进制看做整数，右移1位相当于除以2。 例如： 123int a = 4; // 100a = a &gt;&gt; 2; // 001，等于1a = a &lt;&lt; 3 // 1000，变为8 逻辑运算有： 按位与 &amp;：两位都为1才为1 按位或 |：只要有一位为1，就为1 按位取反 ~： 1变为0，0变为1 按位异或 ^ ：相异为真，相同为假 大部分都比较简单，就不详细说了。具体形式，例如： 123int a = ...;a = a &amp; 0x1 // 返回0或1，就是a最右边一位的值。a = a | 0x1 //不管a原来最右边一位是什么，都将设为1 小结本节我们讨论了整数的二进制表示，需要注意的就是负数的二进制表示，以及计算机进行二进制加减操作的过程，从而我们就能理解为什么有的时候正整数计算会出现负数。 理解了整数，那小数呢？请见下节分享。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"基本运算","slug":"基本运算","date":"2018-04-05T14:09:37.000Z","updated":"2020-03-31T16:15:04.330Z","comments":true,"path":"2018/04/05/基本运算/","link":"","permalink":"http://example.com/2018/04/05/%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97/","excerpt":"","text":"运算计算机之所以称为”计算”机，是因为发明它的主要目的就是运算。运算有不同的类型，不同的数据类型支持的运算也不一样，本文介绍Java中基本类型数据的主要运算。 算术运算：主要是日常的加减乘除 比较运算：主要是日常的大小比较 逻辑运算：针对布尔值进行运算 算术运算算术运算符有加减乘除，符号分别是+-*/，另外还有取模运算符%，以及自增(++)和自减(–)运算符。取模运算适用于整数和字符类型，其他算术运算适用于所有数值类型和字符类型，其他都符合常识，但字符类型看上去比较奇怪，后续文章解释。 减号(-)通常用于两个数相减， 但也可以放在一个数前面，例如 -a, 这表示改变a的符号，原来的正数会变为负数，原来的负数会变为正数，这也是符合我们常识的。 取模(%)就是数学中的求余数，例如，5%3是2，10%5是0。 自增(++)和自减(–)，是一种快捷方式，是对自己进行加一或减一操作。 加减乘除大部分情况和直观感觉是一样的，都很容易理解，但有一些需要注意的地方，而自增自减稍微复杂一些，下面我们解释下。 加减乘除注意事项 运算时要注意结果的范围，使用恰当的数据类型。两个正数都可以用int表示，但相乘的结果可能就会超，超出后结果会令人困惑，例如： 1int a = 2147483647*2; //2147483647是int能表示的最大值 a的结果是-2。为什么是-2我们暂不解释，要避免这种情况，我们的结果类型应使用long，但只改为long也是不够的，因为运算还是默认按照int类型进行，需要将至少一个数据表示为long形式，即在后面加L或l，下面这样才会出现期望的结果： 1long a = 2147483647*2L; 另外，需要注意的是，整数相除不是四舍五入，而是直接舍去小数位，例如： 1double d = 10/4; 结果是2而不是2.5，如果要按小数进行运算，需要将至少一个数表示为小数形式，或者使用强制类型转化，即在数字前面加(double)，表示将数字看做double类型，如下所示任意一种形式都可以： 12double d = 10/4.0;double d = 10/(double)4; 小数计算结果不精确 无论是使用float还是double，进行运算时都会出现一些非常令人困惑的现象，比如： 12float f = 0.1f*0.1f;System.out.println(f); 这个结果看上去，不言而喻，应该是0.01，但实际上，屏幕输出却是0.010000001，后面多了个1。换用double看看： 12double d = 0.1*0.1;System.out.println(d); 屏幕输出0.010000000000000002，一连串的0之后多了个2，结果也不精确。 这是怎么回事？看上去这么简单的运算，计算机怎么能计算不精确呢？但事实就是这样，究其原因，我们需要理解float和double的二进制表示，后续文章进行分析。 自增(++)/自减(–) 自增/自减是对自己做加一和减一操作，但每个都有两种形式，一种是放在变量后，例如a++, a–，另一种是放在变量前，例如++a, –a。 如果只是对自己操作，这两种形式也没什么差别，区别在于还有其他操作的时候。放在变量后(a++)，是先用原来的值进行其他操作，然后再对自己做修改，而放在变量前(++a)，是先对自己做修改，再用修改后的值进行其他操作。例如，快捷运算和其等同的运算分别是： 快捷运算 等同运算 b=a++-1 b=a-1 a=a+1 c = ++a-1 a=a+1 c=a-1 arrA[i++]=arrB[++j] j=j+1 arrA[i]=arrB[j] i=i+1 自增/自减是”快捷”操作，是让程序员少写代码的，但遗憾的是，由于比较奇怪的语法和诡异的行为，带给了初学者一些困惑。 比较运算比较运算就是计算两个值之间的关系，结果是一个布尔类型(boolean)的值。比较运算适用于所有数值类型和字符类型。数值类型容易理解，但字符怎么比呢？后续文章解释。 比较操作符有：大于(&gt;)，大于等于(&gt;=)，小于(&lt;)，小于等于(&lt;=)，等于(==)，不等于(!=)。 大部分也都是比较直观的，需要注意的是等于。 首先，它使用两个等号==，而不是一个等号(=)，为什么不用一个等号呢？因为一个等号(=)已经被占了，表示赋值操作。 另外，对于数组，==判断的是两个数组是不是同一个数组，而不是两个数组的元素内容是否一样，即使两个数组的内容是一样的，但如果是两个不同的数组，==依然会返回false，如下所示： 123int[] a = new int[] &#123;1,2,3&#125;;int[] b = new int[] &#123;1,2,3&#125;;// a==b的结果是false 如果需要比较数组的内容是否一样，需要逐个比较里面存储的每个元素。 逻辑运算逻辑运算根据数据的逻辑关系，生成一个布尔值true或者false。逻辑运算只可应用于boolean类型的数据，但比较运算的结果是布尔值，所以其他类型数据的比较结果可进行逻辑运算。 逻辑运算符具体有： 与(&amp;)：两个都为true才是true，只要有一个是false就是false 或(|)：只要有一个为true就是true，都是false才是false 非(!)：针对一个变量，true会变成false, false会变成true 异或(^)：两个相同为false, 两个不相同为true 短路与(&amp;&amp;): 和&amp;类似，不同之处马上解释 短路或 (||)：与|类似，不同之处马上解释逻辑运算的大部分都是比较直观的，需要注意的是&amp;和&amp;&amp;，以及|和||的区别。如果只是进行逻辑运算，它们也都是相同的，区别在于同时有其他操作的情况下，例如：123boolean a = true;int b = 0;boolean flag = a | b++&gt;0; 因为a为true，所以flag也为true，但b的结果为1，因为|后面的式子也会进行运算，即使只看a已经知道flag的结果，还是会进行后面的运算。而||则不同，如果最后一句的代码是：1boolean flag = a || b++&gt;0; 则b的值还是0，因为||会”短路”，即在看到||前面部分就可以判定结果的情况下，忽略||后面的运算。 这个例子我们还可以看出，自增/自减操作带给我们的困扰，别的操作都干干脆脆，赋值就赋值，加法就加法，比较就比较，它非混在一起，可能会少写些代码，但如果使用不当，会使理解困难很多。 运算符优先级一个稍微复杂的运算可能会涉及多个变量，和多种运算，那哪个先算，哪个后算呢？程序语言规定了不同运算符的优先级，有的会先算，有的会后算，大部分情况下，这个优先级与我们的常识理解是相符的。 但在一些复杂情况下，我们可能会搞不明白其运算顺序。但这个我们不用太操心，可以使用括号()来表达我们想要的顺序，括号里的会先进行运算，简单的说，不确定顺序的时候，就使用括号。 小结本节我们介绍了算术运算，比较运算和逻辑运算，但我们遗留了一些问题，比如： 正整数相乘的结果居然出现了负数 非常基本的小数运算结果居然不精确 字符类型怎么也可以进行算术运算和比较 这是怎么回事呢? 请见下节分享。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"变量赋值","slug":"变量赋值","date":"2018-04-01T14:09:37.000Z","updated":"2020-03-31T15:50:05.496Z","comments":true,"path":"2018/04/01/变量赋值/","link":"","permalink":"http://example.com/2018/04/01/%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC/","excerpt":"","text":"赋值通过声明变量，每个变量赋予一个数据类型和一个有意义的名字，我们就告诉了计算机我们要操作的数据。有了数据，我们能做很多操作。但本文只说说对数据做的第一个操作：赋值 声明变量之后，就在内存分配了一块位置，但这个位置的内容是未知的，赋值就是把这块位置的内容设为一个确定的值。 Java中基本类型、数组、对象的赋值有明显不同。这里先介绍基本类型和数组的赋值，关于对象后续文章会详述。 基本类型的赋值整数类型整数类型有byte, short, int和long，分别占用1/2/4/8个字节，取值范围分别是： 类型名 取值范围 byte -2^7 ~ 2^7-1 short -2^15 ~ 2^15-1 int -2^31 ~ 2^31-1 long -2^63 ~ 2^63-1 我们用^表示指数，2^7即2的7次方。这个范围我们不需要记的那么清楚，有个大概范围认识就可以了，大多数日常应用，一般用int就可以了。后续文章会从二进制的角度进一步分析表示范围为什么会是这样的。 赋值形式很简单，直接把熟悉的数字常量形式赋值给变量即可，对应的内存空间的值就从未知变成了确定的常量。但常量不能超过对应类型的表示范围。例如： 1234byte b = 23;short s = 3333;int i = 9999;long l = 32323; 但是，在给long类型赋值时，如果常量超过了int的表示范围，需要在常量后面加大写或小写的L，即L或l，例如: 1long a = 3232343433L; 这个是由于数字常量默认为是int类型。 小数类型 小数类型有float和double，占用的内存空间分别是4和8个字节，有不同的取值范围和精度，double表示的范围更大，精度更高，具体来说： 类型名 取值范围 float 1.4E-45 ~ 3.4E+38 -3.4E+38 ~-1.4E-45 double 4.9E-324 ~1.7E+308 -1.7E+308 ~ -4.9E-324 取值范围看上去很奇怪，一般我们也不需要记住，有个大概印象就可以了。E表示以10为底的指数，E后面的+号和-号代表正指数和负指数，例如：1.4E-45表示1.4乘以10的-45次方。 对于double，直接把熟悉的小数表示赋值给变量即可，例如： 1double d = 333.33; 但对于float，需要在数字后面加大写F或小写f，例如： 1float f = 333.33f; 这个是由于小数常量默认为是double类型。 除了小数，也可以把整数直接赋值给float或double，例如： 12float f = 33;double d = 3333333333333L; boolean类型 这个很简单，直接使用true或false赋值，分别表示真和假，例如： 12boolean b = true;b = false; 字符类型 字符类型char用于表示一个字符，这个字符可以是中文字符，也可以是英文字符。在内存中，Java用两个字节表示一个字符。赋值时把常量字符用单引号括起来，不要使用双引号，例如：java 12char c = &#x27;A&#x27;;char z = &#x27;中&#x27;; 上面介绍的赋值都是在声明变量的时候就进行了赋值，但这不是必须的，可以先声明变量，随后再进行赋值。 数组类型赋值语法 基本类型的数组有三种赋值形式，如下所示： 12341. int[] arr = &#123;1,2,3&#125;;2. int[] arr = new int[]&#123;1,2,3&#125;;3. int[] arr = new int[3]; arr[0]=1; arr[1]=2; arr[2]=3; 第一种和第二种都是预先知道数组的内容，而第三种是先分配长度，然后再给每个元素赋值。 第三种形式中，即使没有给每个元素赋值，每个元素也都有一个默认值，这个默认值跟数组类型有关。数值类型的值为0，boolean为false, char为空字符。 数组长度可以动态确定，如下所示： 12int length = ... ;//根据一些条件动态计算int arr = new int[length]; 虽然可以动态确定，但定了之后就不可以变，数组有一个length属性，但只能读，不能改。 一个小细节，不能在给定初始值的同时还给定长度，即如下格式是不允许的： 1int[] arr = new int[3]&#123;1,2,3&#125; 数组和基本类型的区别 一个基本类型变量，内存中只会有一块对应的内存空间。但数组有两块，一块用于存储数组内容本身，另一块用于存储内容的位置。 用一个例子来说明，有一个int变量a，和一个int数组变量arr，其代码，变量对应的内存地址和内存内容如下所示： 代码 内存地址 内存数据 int a = 100; 1000 100 int[] arr = {1,2,3}; 2000 3000 3000 1 3004 2 3008 3 基本类型a的内存地址是1000，这个位置存储的就是它的值100。数组类型arr的内存地址是2000，这个位置存储的值是一个位置3000，3000开始的位置存储的才是实际的数据1,2,3。 为什么数组要用两块空间 不能只用一块空间吗？我们来看下面这个代码： 123int[] arrA = &#123;1,2,3&#125;;int[] arrB = &#123;4,5,6,7&#125;;arrA = arrB; 这个代码中，arrA初始的长度是3，arrB的长度是4，后来将arrB的值赋给了arrA。如果arrA对应的内存空间是直接存储的数组内容，那么它将没有足够的空间去容纳arrB的所有元素。 用两块空间存储，这个就简单的多，arrA存储的值就变成了和arrB的一样，存储的都是数组内容{4,5,6,7}的地址，此后访问arrA就和arrB是一样的了，而arrA {1,2,3}的内存空间由于无人引用会被垃圾回收，如下所示 1234567arrA &#123;1,2,3&#125; \\ \\arrB -&gt; &#123;4,5,6,7&#125; 由上，也可以看出，给数组变量赋值和给数组中元素赋值是两回事。给数组中元素赋值是改变数组内容，而给数组变量赋值则会让变量指向一个不同的位置。 上面我们说数组的长度是不可以变的，不可变指的是数组的内容空间，一经分配，长度就不能再变了，但是可以改变数组变量的值，让它指向一个长度不同的空间，就像上例中arrA后来指向了arrB一样。 小结给变量赋值就是将变量对应的内存空间设置为一个明确的值，有了值之后，变量可以被加载到CPU，CPU可以对这些值进行各种运算，运算后的结果又可以被赋值给变量，保存到内存中。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"数据与变量","slug":"数据与变量","date":"2018-03-31T14:09:37.000Z","updated":"2020-03-31T15:52:53.429Z","comments":true,"path":"2018/03/31/数据与变量/","link":"","permalink":"http://example.com/2018/03/31/%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%8F%98%E9%87%8F/","excerpt":"","text":"程序大概是怎么回事计算机就是个机器，这个机器主要由CPU、内存、硬盘和输入输出设备组成。计算机上跑着操作系统，如Windows或Linux，操作系统上运行着各种应用程序，如Word, QQ等。操作系统将时间分成很多细小的时间片，一个时间片给一个程序用，另一个时间片给另一个程序用，并频繁地在程序间切换。不过，在应用程序看来，整个机器资源好像都归他使，操作系统给他提供了这种假象。 对程序员而言，我们写程序，基本不用考虑其他应用程序，我们想好怎么做自己的事就可以了。应用程序看上去能做很多事情，能读写文档，能播放音乐，能聊天，能玩游戏，能下围棋 …… 但本质上，计算机只会执行预先写好的指令而已，这些指令也只是操作数据或者设备。所谓程序，基本上就是告诉计算机要操作的数据和执行的指令序列， 即对什么数据做什么操作。 数据数据是什么？数据在计算机内部都是二进制，不方便操作，为了方便操作数据，高级语言引入了”数据类型”和”变量”的概念。 数据类型数据类型用于对数据归类，方便理解和操作，对Java语言而言，有如下基本数据类型： 整数类型：有四种整型 byte/short/int/long，分别有不同的取值范围 小数类型 ：有两种类型 float/double，有不同的取值范围和精度 字符类型：char，表示单个字符 真假类型：boolean，表示真假 基本数据类型都有对应的数组类型，数组表示固定长度的同种数据类型的多条记录，这些数据在内存中挨在一起存放。 比如说，一个自然数可以用一个整数类型数据表示，100个连续的自然数可以用一个长度为100的整数数组表示。一个字符用一个char表示，一段文字可以用一个char数组表示。Java是一个面向对象的语言，除了基本数据类型，其他都是对象类型 ，对象到底是什么呢？简单的说，对象是由基本数据类型、数组和其他对象组合而成的一个东西，以方便对其整体进行操作。 比如说，一个学生对象，可以由如下信息组成： 姓名：一个字符数组 年龄：一个整数 性别：一个字符 入学分数：一个小数 日期在Java中也是一个对象，内部表示为整形long。就像世界万物的组成，都是由元素周期表中的108个基本元素组成的，基本数据类型就相当于化学中的基本元素，而对象就相当于世界万物。 变量为了操作数据，需要把数据存放到内存中，所谓内存在程序看来就是一块有地址编号的连续的空间，放到内存中的某个位置后，为了方便地找到和操作这个数据，需要给这个位置起一个名字。编程语言通过变量这个概念来表示这个过程。 声明一个变量，比如 int a其实就是在内存中分配了一个空间，这个空间存放int数据类型，a指向这个内存空间所在的位置，通过对a操作即可操作a指向的内存空间，比如a=5这个操作即可将a指向的内存空间的值改为5。 之所以叫变量，是因为它表示的是内存中的位置，这个位置存放的值是可以变化的。 虽然变量的值是可以变化的，但名字是不变的，这个名字应该代表程序员心目中这块内存位置的意义，这个意义应该是不变的，比如说这个变量int second表示时钟秒数，在不同时间可以被赋予不同的值，但它表示的就是时钟秒数。之所以说应该是因为这不是必须的，如果你非要起一个变量名叫age但赋予它身高的值，计算机也拿你没办法。 重要的话再说一遍！变量就是给数据起名字，方便找不同的数据，它的值可以变，但含义不应变。再比如说一个合同，可以有四个变量： first_party: 含义是甲方 second_party: 含义是乙方 contract_body: 含义是合同内容 contract_sign_date: 含义是合同签署日期 这些变量表示的含义是确定的，但对不同的合同，他们的值是不同的。 初学编程的人经常使用像a,b,c,hehe,haha这种无意义的名字，给变量起一个有意义的名字吧!","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"如何将Hexo托管到GitHub","slug":"如何将Hexo托管到GitHub","date":"2016-07-26T14:20:47.000Z","updated":"2020-03-31T16:33:01.546Z","comments":true,"path":"2016/07/26/如何将Hexo托管到GitHub/","link":"","permalink":"http://example.com/2016/07/26/%E5%A6%82%E4%BD%95%E5%B0%86Hexo%E6%89%98%E7%AE%A1%E5%88%B0GitHub/","excerpt":"","text":"如何将Hexo托管到GitHub托管步骤步骤1：首先，你要先有一个GitHub账户，没有就去注册一个吧。注册完登录后，会在GitHub.com中看到一个New repository（新建仓库）。 步骤2：创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxx.github.io，其中xxx就是你注册GitHub的用户名。 步骤3：生成SSH添加到GitHub，在Git bash中输入如下命令： 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱，这样GitHub才能知道你是不是它的账户。可以用以下两条命令检查你现在的用户名和邮箱： 12git config user.namegit config user.email 然后创建SSH，输入如下命令： 1ssh-keygen -t rsa -C &quot;youremail&quot; 之后一路回车就行。SSH简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。步骤4：在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key把你的id_rsa.pub里面的信息复制进去，通过如下命令查看是否设置成功： 1ssh -T git@github.com 完成这一步，我们就将hexo和GitHub关联起来了。步骤5：打开我们之前介绍的站点配置文件_config.yml，找到如下内容： 1234deploy: type: git repo: git@github.com:[yourname]&#x2F;[yourname].github.io.git branch: master 修改[yourname]为你的GitHub账户，然后输入安装deploy-git的命令 ： 1npm install hexo-deployer-git --save 这样你才能用命令部署到GitHub。步骤6：最后输入如下命令： 123hexo cleanhexo generatehexo deploy hexo clean 清除你之前生成的东西，也可以不加。hexo generate (可缩写hexo g) 顾名思义，生成静态文章hexo deploy (可缩写hexo d) 部署文章 设置个人域名现在你的个人博客网站的地址默认是yourname.github.io，如果你觉得这个网址逼格太low了，则可以设置自己的个人域名。步骤1：如果你没有自己的域名，你就需要花钱去注册或买一个自己域名，一般在域名购买网站的域名管理后台中你可以看到你购买的域名。你可以添加解析，将GitHub的服务器地址设置进去192.30.252.153 和 192.30.252.154 是GitHub的服务器地址。 解析线路一般选择默认，但你也可以用这个来做国内外分流。 步骤2：登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名。然后在你的博客文件source中创建一个名为CNAME文件，不要后缀，写上你的域名。 步骤3：最后重新部署一下即可： 123hexo cleanhexo ghexo d","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]},{"title":"Hexo博客开源框架的使用","slug":"Hexo博客开源框架的使用","date":"2016-07-02T11:30:14.000Z","updated":"2021-04-01T06:23:18.701Z","comments":true,"path":"2016/07/02/Hexo博客开源框架的使用/","link":"","permalink":"http://example.com/2016/07/02/Hexo%E5%8D%9A%E5%AE%A2%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Hexo介绍Hexo是一款基于Node.js的开源博客框架。你可以用MarkDown（或者其他标记语言）来书写自己的博客，然后通过Hexo快速生成静态的博客站点，还可将其托管到GitHub上，使用起来十分方便。当然，Hexo也允许你应用许多漂亮的主题来装饰自己的站点，你可以通过Hexo主题市场来获取你感兴趣的主题。 Hexo博客站点搭建环境准备需要先安装配置以下两个环境，如已安装请忽略此步 Git Node.js这里建议均安装最新版本，因为Hexo是在不断更新的，需要依赖最新的环境。 安装完后注意检查环境变量的配置，在CMD中通过以下命令来检查是否配置成功： 12node -v npm -v 1git --version ### 安装Hexo 当以上环境都安装好后，就可以利用[npm](https://www.npmjs.com/)来安装Hexo了。新建一个文件夹，进入该文件夹然后右键Git Bash Here，在命令窗口输入以下命令安装Hexo： 1npm install -g hexo-cli 接着输入初始化Hexo命令，该命令会在该文件夹下新生成一个blog文件夹，放置Hexo主要的工作文件： 1hexo init blog 进入blog文件夹，安装Hexo依赖的插件： 12cd blognpm install 此时该文件夹的目录结构变为： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 启动Hexo站点： 1hexo server 在[http://localhost:4000/](http://localhost:4000/)中查看Hexo生成的默认站点，Hexo安装就大功告成了。 ### 配置Hexo 这里介绍一些比较重要的配置 打开blog文件夹下的_config.yml文件，可对Hexo站点进行一些基本的配置 title:站点显示名称description:站点描述author:作者post_asset_folder:站点部署的时候允许上传资源文件夹（如果要上传图片则设为true）theme:设置主题的名称deploy:远程部署站点的相关设置 Hexo基本操作初始化站点 1hexo init [folder] folder为你指定的文件夹名称，没有则自动创建新建文章 1hexo new [layout] &lt;title&gt; 如果没有指定layout，则会使用_config.yml中定义的默认layout；title为生成的.md文件兼文章的标题，文章标题也可到具体的文件中去修改，生成的文件位于/source/_posts/目录下 清理缓存和生成的文件 1hexo clean 清理缓存文件（db.json）和生成的文件(public) 生成网站的静态文件 1hexo generate 或 hexo g 启动一个本地站点 1hexo server 或 hexo s 默认地址为http://localhost:4000/，一般用于调试和查看效果部署站点 1hexo deploy 需配合_config.yml中配置的deploy使用，将自己的本地站点文件部署到远程服务器或仓库。","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]}],"categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"},{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]}