{"meta":{"title":"RedPig's Blog","subtitle":"","description":"","author":"RedPig","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Java异常体系以及应用","slug":"Java异常体系以及应用","date":"2018-06-10T10:00:42.000Z","updated":"2021-04-24T05:59:47.251Z","comments":true,"path":"2018/06/10/Java异常体系以及应用/","link":"","permalink":"http://example.com/2018/06/10/Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/","excerpt":"","text":"之前我们介绍的基本类型、类、接口、枚举都是在表示和操作数据，操作的过程中可能有很多出错的情况，出错的原因可能是多方面的，有的是不可控的内部原因，比如内存不够了、磁盘满了，有的是不可控的外部原因，比如网络连接有问题，更多的可能是程序的编程错误，比如引用变量未初始化就直接调用实例方法。 这些非正常情况在Java中统一被认为是异常，Java使用异常机制来统一处理，接下来我们会介绍对异常的初步认识，异常类本身，以及对异常的处理等相关知识。 好了，我们先来通过一些例子认识一下异常。 初始异常NullPointerException (空指针异常)我们来看段代码： 1234567public class ExceptionTest &#123; public static void main(String[] args) &#123; String s = null; s.indexOf(&quot;a&quot;); System.out.println(&quot;end&quot;); &#125;&#125; 变量s没有初始化就调用其实例方法indexOf，运行，屏幕输出为： 12Exception in thread &quot;main&quot; java.lang.NullPointerException at ExceptionTest.main(ExceptionTest.java:5) 输出是告诉我们：在ExceptionTest类的main函数中，代码第5行，出现了空指针异常(java.lang.NullPointerException)。 但，具体发生了什么呢？当执行s.indexOf(“a”)的时候，Java系统发现s的值为null，没有办法继续执行了，这时就启用异常处理机制，首先创建一个异常对象，这里是类NullPointerException的对象，然后查找看谁能处理这个异常，在示例代码中，没有代码能处理这个异常，Java就启用默认处理机制，那就是打印异常栈信息到屏幕，并退出程序。 异常栈信息就包括了从异常发生点到最上层调用者的轨迹，还包括行号，可以说，这个栈信息是分析异常最为重要的信息。 Java的默认异常处理机制是退出程序，异常发生点后的代码都不会执行，所以示例代码中最后一行System.out.println(“end”)不会执行。 NumberFormatException (数字格式异常)我们再来看一个例子，代码如下： 12345678910public class ExceptionTest &#123; public static void main(String[] args) &#123; if(args.length&lt;1)&#123; System.out.println(&quot;请输入数字&quot;); return; &#125; int num = Integer.parseInt(args[0]); System.out.println(num); &#125;&#125; args表示命令行参数，这段代码要求参数为一个数字，它通过Integer.parseInt将参数转换为一个整数，并输出这个整数。参数是用户输入的，我们没有办法强制用户输入什么，如果用户输的是数字，比如123，屏幕会输出123，但如果用户输的不是数字，比如abc，屏幕会输出： 12345Exception in thread &quot;main&quot; java.lang.NumberFormatException: For input string: &quot;abc&quot; at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.lang.Integer.parseInt(Integer.java:492) at java.lang.Integer.parseInt(Integer.java:527) at ExceptionTest.main(ExceptionTest.java:7) 出现了异常NumberFormatException。这个异常是怎么产生的呢？根据异常栈信息，我们看相关代码： 这是NumberFormatException类65行附近代码： 12364 static NumberFormatException forInputString(String s) &#123;65 return new NumberFormatException(&quot;For input string: \\&quot;&quot; + s + &quot;\\&quot;&quot;);66 &#125; 这是Integer类492行附近代码： 1234567490 digit = Character.digit(s.charAt(i++),radix);491 if (digit &lt; 0) &#123;492 throw NumberFormatException.forInputString(s);493 &#125;494 if (result &lt; multmin) &#123;495 throw NumberFormatException.forInputString(s);496 &#125; 将这两处合为一行，主要代码就是： 1throw new NumberFormatException(...) new NumberFormatException(…)是我们容易理解的，就是创建了一个类的对象，只是这个类是一个异常类。throw是什么意思呢？就是抛出异常，它会触发Java的异常处理机制。在之前的空指针异常中，我们没有看到throw的代码，可以认为throw是由Java虚拟机自己实现的。 throw关键字可以与return关键字进行对比，return代表正常退出，throw代表异常退出，return的返回位置是确定的，就是上一级调用者，而throw后执行哪行代码则经常是不确定的，由异常处理机制动态确定。 异常处理机制会从当前函数开始查找看谁”捕获”了这个异常，当前函数没有就查看上一层，直到主函数，如果主函数也没有，就使用默认机制，即输出异常栈信息并退出，这正是我们在屏幕输出中看到的。 对于屏幕输出中的异常栈信息，程序员是可以理解的，但普通用户无法理解，也不知道该怎么办，我们需要给用户一个更为友好的信息，告诉用户，他应该输入的是数字，要做到这一点，我们需要自己”捕获”异常。 “捕获”是指使用try/catch关键字，我们看捕获异常后的示例代码： 123456789101112131415public class ExceptionTest &#123; public static void main(String[] args) &#123; if(args.length&lt;1)&#123; System.out.println(&quot;请输入数字&quot;); return; &#125; try&#123; int num = Integer.parseInt(args[0]); System.out.println(num); &#125;catch(NumberFormatException e)&#123; System.err.println(&quot;参数&quot;+args[0] +&quot;不是有效的数字，请输入数字&quot;); &#125; &#125;&#125; 我们使用try/catch捕获并处理了异常，try后面的大括号{}内包含可能抛出异常的代码，括号后的catch语句包含能捕获的异常和处理代码，catch后面括号内是异常信息，包括异常类型和变量名，这里是NumberFormatException e，通过它可以获取更多异常信息，大括号{}内是处理代码，这里输出了一个更为友好的提示信息。 捕获异常后，程序就不会异常退出了，但try语句内异常点之后的其他代码就不会执行了，执行完catch内的语句后，程序会继续执行catch大括号外的代码。 这样，我们就对异常有了一个初步的了解，异常是相对于return的一种退出机制，可以由系统触发，也可以由程序通过throw语句触发，异常可以通过try/catch语句进行捕获并处理，如果没有捕获，则会导致程序退出并输出异常栈信息。异常有不同的类型，接下来，我们来认识一下。 异常类ThrowableNullPointerException和NumberFormatException都是异常类，所有异常类都有一个共同的父类Throwable，它有4个public构造方法： public Throwable() public Throwable(String message) public Throwable(String message, Throwable cause) public Throwable(Throwable cause) 有两个主要参数，一个是message，表示异常消息，另一个是cause，表示触发该异常的其他异常。异常可以形成一个异常链，上层的异常由底层异常触发，cause表示底层异常。 Throwable还有一个public方法用于设置cause： 1Throwable initCause(Throwable cause) Throwable的某些子类没有带cause参数的构造方法，就可以通过这个方法来设置，这个方法最多只能被调用一次。 所有构造方法中都有一句重要的函数调用： 1fillInStackTrace(); 它会将异常栈信息保存下来，这是我们能看到异常栈的关键。 Throwable有一些常用方法用于获取异常信息： 1void printStackTrace() 打印异常栈信息到标准错误输出流，它还有两个重载的方法： 12void printStackTrace(PrintStream s)void printStackTrace(PrintWriter s) 打印栈信息到指定的流，关于PrintStream和PrintWriter我们后续文章介绍。 12String getMessage()Throwable getCause() 获取设置的异常message和cause 1StackTraceElement[] getStackTrace() 获取异常栈每一层的信息，每个StackTraceElement包括文件名、类名、函数名、行号等信息。 异常类体系以Throwable为根，Java API中定义了非常多的异常类，表示各种类型的异常，部分类示意如下： Throwable是所有异常的基类，它有两个子类Error和Exception。 Error表示系统错误或资源耗尽，由Java系统自己使用，应用程序不应抛出和处理，比如图中列出的虚拟机错误(VirtualMacheError)及其子类内存溢出错误(OutOfMemoryError)和栈溢出错误(StackOverflowError)。 Exception表示应用程序错误，它有很多子类，应用程序也可以通过继承Exception或其子类创建自定义异常，图中列出了三个直接子类：IOException(输入输出I/O异常)，SQLException(数据库SQL异常)，RuntimeException(运行时异常)。 RuntimeException(运行时异常)比较特殊，它的名字有点误导，因为其他异常也是运行时产生的，它表示的实际含义是unchecked exception (未受检异常)，相对而言，Exception的其他子类和Exception自身则是checked exception (受检异常)，Error及其子类也是unchecked exception。 checked还是unchecked，区别在于Java如何处理这两种异常，对于checked异常，Java会强制要求程序员进行处理，否则会有编译错误，而对于unchecked异常则没有这个要求。 RuntimeException也有很多子类，下表列出了其中常见的一些： 异常 说明 NullPointerException 空指针异常 IllegalStateException 非法状态 ClassCastException 非法强制类型转换 IllegalArgumentException 参数错误 NumberFormatException 数字格式错误 IndexOutOfBoundsException 索引越界 ArrayIndexOutOfBoundsException 数组索引越界 StringIndexOutOfBoundsException 字符串索引越界 这么多不同的异常类其实并没有比Throwable这个基类多多少属性和方法，大部分类在继承父类后只是定义了几个构造方法，这些构造方法也只是调用了父类的构造方法，并没有额外的操作。 那为什么定义这么多不同的类呢？主要是为了名字不同，异常类的名字本身就代表了异常的关键信息，无论是抛出还是捕获异常时，使用合适的名字都有助于代码的可读性和可维护性。 自定义异常除了Java API中定义的异常类，我们也可以自己定义异常类，一般通过继承Exception或者它的某个子类，如果父类是RuntimeException或它的某个子类，则自定义异常也是unchecked exception，如果是Exception或Exception的其他子类，则自定义异常是checked exception。 我们通过继承Exception来定义一个异常，代码如下： 123456789101112131415161718public class AppException extends Exception &#123; public AppException() &#123; super(); &#125; public AppException(String message, Throwable cause) &#123; super(message, cause); &#125; public AppException(String message) &#123; super(message); &#125; public AppException(Throwable cause) &#123; super(cause); &#125;&#125; 和很多其他异常类一样，我们没有定义额外的属性和代码，只是继承了Exception，定义了构造方法并调用了父类的构造方法。 异常处理catch匹配上面我们简单介绍了使用try/catch捕获异常，其中catch只有一条，其实，catch还可以有多条，每条对应一个异常类型，比如说： 123456789try&#123; //可能触发异常的代码&#125;catch(NumberFormatException e)&#123; System.out.println(&quot;not valid number&quot;);&#125;catch(RuntimeException e)&#123; System.out.println(&quot;runtime exception &quot;+e.getMessage());&#125;catch(Exception e)&#123; e.printStackTrace();&#125; 异常处理机制将根据抛出的异常类型找第一个匹配的catch块，找到后，执行catch块内的代码，其他catch块就不执行了，如果没有找到，会继续到上层方法中查找。需要注意的是，抛出的异常类型是catch中声明异常的子类也算匹配，所以需要将最具体的子类放在前面，如果基类Exception放在前面，则其他更具体的catch代码将得不到执行。 示例也演示了对异常信息的利用，e.getMessage()获取异常消息，e.printStackTrace()打印异常栈到标准错误输出流。通过这些信息有助于理解为什么会出异常，这是解决编程错误的常用方法。示例是直接将信息输出到标准流上，实际系统中更常用的做法是输出到专门的日志中。 重新throw在catch块内处理完后，可以重新抛出异常，异常可以是原来的，也可以是新建的，如下所示： 123456789try&#123; //可能触发异常的代码&#125;catch(NumberFormatException e)&#123; System.out.println(&quot;not valid number&quot;); throw new AppException(&quot;输入格式不正确&quot;, e);&#125;catch(Exception e)&#123; e.printStackTrace(); throw e;&#125; 对于Exception，在打印出异常栈后，就通过throw e重新抛出了。 而对于NumberFormatException，我们重新抛出了一个AppException，当前Exception作为cause传递给了AppException，这样就形成了一个异常链，捕获到AppException的代码可以通过getCause()得到NumberFormatException。 为什么要重新抛出呢？因为当前代码不能够完全处理该异常，需要调用者进一步处理。 为什么要抛出一个新的异常呢？当然是当前异常不太合适，不合适可能是信息不够，需要补充一些新信息，还可能是过于细节，不便于调用者理解和使用，如果调用者对细节感兴趣，还可以继续通过getCause()获取到原始异常。 finally异常机制中还有一个重要的部分，就是finally, catch后面可以跟finally语句，语法如下所示： 1234567try&#123; //可能抛出异常&#125;catch(Exception e)&#123; //捕获异常&#125;finally&#123; //不管有无异常都执行&#125; finally内的代码不管有无异常发生，都会执行。具体来说： 如果没有异常发生，在try内的代码执行结束后执行。 如果有异常发生且被catch捕获，在catch内的代码执行结束后执行 如果有异常发生但没被捕获，则在异常被抛给上层之前执行。 由于finally的这个特点，它一般用于释放资源，如数据库连接、文件流等。 try/catch/finally语法中，catch不是必需的，也就是可以只有try/finally，表示不捕获异常，异常自动向上传递，但finally中的代码在异常发生后也执行。 finally语句有一个执行细节，如果在try或者catch语句内有return语句，则return语句在finally语句执行结束后才执行，但finally并不能改变返回值。我们来看下代码： 12345678public static int test()&#123; int ret = 0; try&#123; return ret; &#125;finally&#123; ret = 2; &#125;&#125; 这个函数的返回值是0，而不是2，实际执行过程是，在执行到try内的return ret;语句前，会先将返回值ret保存在一个临时变量中，然后才执行finally语句，最后try再返回那个临时变量，finally中对ret的修改不会被返回。 如果在finally中也有return语句呢？try和catch内的return会丢失，实际会返回finally中的返回值。finally中有return不仅会覆盖try和catch内的返回值，还会掩盖try和catch内的异常，就像异常没有发生一样。比如说： 123456789public static int test()&#123; int ret = 0; try&#123; int a = 5/0; return ret; &#125;finally&#123; return 2; &#125;&#125; 以上代码中，5/0会触发ArithmeticException，但是finally中有return语句，这个方法就会返回2，而不再向上传递异常了。 finally中不仅return语句会掩盖异常，如果finally中抛出了异常，则原异常就会被掩盖。看下面代码： 1234567public static void test()&#123; try&#123; int a = 5/0; &#125;finally&#123; throw new RuntimeException(&quot;hello&quot;); &#125;&#125; finally中抛出了RuntimeException，则原异常ArithmeticException就丢失了。 所以，一般而言，为避免混淆，应该避免在finally中使用return语句或者抛出异常，如果调用的其他代码可能抛出异常，则应该捕获异常并进行处理。 throws 异常机制中，还有一个和throw很像的关键字throws，用于声明一个方法可能抛出的异常，语法如下所示： 123public void test() throws AppException, SQLException, NumberFormatException &#123; //....&#125; throws跟在方法的括号后面，可以声明多个异常，以逗号分隔。这个声明的含义是说，我这个方法内可能抛出这些异常，我没有进行处理，至少没有处理完，调用者必须进行处理。这个声明没有说明，具体什么情况会抛出什么异常，作为一个良好的实践，应该将这些信息用注释的方式进行说明，这样调用者才能更好的处理异常。 对于RuntimeException(unchecked exception)，是不要求使用throws进行声明的，但对于checked exception，则必须进行声明，换句话说，如果没有声明，则不能抛出。 对于checked exception，不可以抛出而不声明，但可以声明抛出但实际不抛出，不抛出声明它干嘛？主要用于在父类方法中声明，父类方法内可能没有抛出，但子类重写方法后可能就抛出了，子类不能抛出父类方法中没有声明的checked exception，所以就将所有可能抛出的异常都写到父类上了。 如果一个方法内调用了另一个声明抛出checked exception的方法，则必须处理这些checked exception，不过，处理的方式既可以是catch，也可以是继续使用throws，如下代码所示： 1234567public void tester() throws AppException &#123; try &#123; test(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 对于test抛出的SQLException，这里使用了catch，而对于AppException，则将其添加到了自己方法的throws语句中，表示当前方法也处理不了，还是由上层处理吧。 Checked对比Unchecked Exception以上，可以看出RuntimeException(unchecked exception)和checked exception的区别，checked exception必须出现在throws语句中，调用者必须处理，Java编译器会强制这一点，而RuntimeException则没有这个要求。 为什么要有这个区分呢？我们自己定义异常的时候应该使用checked还是unchecked exception啊？对于这个问题，业界有各种各样的观点和争论，没有特别一致的结论。 一种普遍的说法是，RuntimeException(unchecked)表示编程的逻辑错误，编程时应该检查以避免这些错误，比如说像空指针异常，如果真的出现了这些异常，程序退出也是正常的，程序员应该检查程序代码的bug而不是想办法处理这种异常。Checked exception表示程序本身没问题，但由于I/O、网络、数据库等其他不可预测的错误导致的异常，调用者应该进行适当处理。 但其实编程错误也是应该进行处理的，尤其是，Java被广泛应用于服务器程序中，不能因为一个逻辑错误就使程序退出。所以，目前一种更被认同的观点是，Java中的这个区分是没有太大意义的，可以统一使用RuntimeException即unchcked exception来代替。 这个观点的基本理由是，无论是checked还是unchecked异常，无论是否出现在throws声明中，我们都应该在合适的地方以适当的方式进行处理，而不是只为了满足编译器的要求，盲目处理异常，既然都要进行处理异常，checked exception的强制声明和处理就显得啰嗦，尤其是在调用层次比较深的情况下。 其实观点本身并不太重要，更重要的是一致性，一个项目中，应该对如何使用异常达成一致，按照约定使用即可。Java中已有的异常和类库也已经在哪里，我们还是要按照他们的要求进行使用。 如何使用异常针对异常，我们介绍了try/catch/finally, catch匹配、重新抛出、throws、checked/unchecked exception，那到底该如何使用异常呢？ 异常应该且仅用于异常情况这个含义是说，异常不能代替正常的条件判断。比如说，循环处理数组元素的时候，你应该先检查索引是否有效再进行处理，而不是等着抛出索引异常再结束循环。对于一个引用变量，如果正常情况下它的值也可能为null，那就应该先检查是不是null，不为null的情况下再进行调用。 另一方面，真正出现异常的时候，应该抛出异常，而不是返回特殊值，比如说，我们看String的substring方法，它返回一个子字符串，它的代码如下： 12345678910public String substring(int beginIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; int subLen = value.length - beginIndex; if (subLen &lt; 0) &#123; throw new StringIndexOutOfBoundsException(subLen); &#125; return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);&#125; 代码会检查beginIndex的有效性，如果无效，会抛出StringIndexOutOfBoundsException。纯技术上一种可能的替代方法是不抛异常而返回特殊值null，但beginIndex无效是异常情况，异常不能假装当正常处理。 异常处理的目标异常大概可以分为三个来源：用户、程序员、第三方。用户是指用户的输入有问题，程序员是指编程错误，第三方泛指其他情况如I/O错误、网络、数据库、第三方服务等。每种异常都应该进行适当的处理。 处理的目标可以分为报告和恢复。恢复是指通过程序自动解决问题。报告的最终对象可能是用户，即程序使用者，也可能是系统运维人员或程序员。报告的目的也是为了恢复，但这个恢复经常需要人的参与。 对用户，如果用户输入不对，可能提示用户具体哪里输入不对，如果是编程错误，可能提示用户系统错误、建议联系客服，如果是第三方连接问题，可能提示用户稍后重试。 对系统运维人员或程序员，他们一般不关心用户输入错误，而关注编程错误或第三方错误，对于这些错误，需要报告尽量完整的细节，包括异常链、异常栈等，以便尽快定位和解决问题。 对于用户输入或编程错误，一般都是难以通过程序自动解决的，第三方错误则可能可以，甚至很多时候，程序都不应该假定第三方是可靠的，应该有容错机制。比如说，某个第三方服务连接不上(比如发短信)，可能的容错机制是，换另一个提供同样功能的第三方试试，还可能是，间隔一段时间进行重试，在多次失败之后再报告错误。 异常处理的一般逻辑如果自己知道怎么处理异常，就进行处理，如果可以通过程序自动解决，就自动解决，如果异常可以被自己解决，就不需要再向上报告。 如果自己不能完全解决，就应该向上报告。如果自己有额外信息可以提供，有助于分析和解决问题，就应该提供，可以以原异常为cause重新抛出一个异常。 总有一层代码需要为异常负责，可能是知道如何处理该异常的代码，可能是面对用户的代码，也可能是主程序。如果异常不能自动解决，对于用户，应该根据异常信息提供用户能理解和对用户有帮助的信息，对运维和程序员，则应该输出详细的异常链和异常栈到日志。 这个逻辑与在公司中处理问题的逻辑是类似的，每个级别都有自己应该解决的问题，自己能处理的自己处理，不能处理的就应该报告上级，把下级告诉他的，和他自己知道的，一并告诉上级，最终，公司老板必须要为所有问题负责。每个级别既不应该掩盖问题，也不应该逃避责任。 小结本文对异常做了基本介绍，介绍了try/catch和throw关键字及其含义，同时介绍了Throwable以及以它为根的异常类体系，同时还介绍了Java中的异常机制。 在没有异常机制的情况下，唯一的退出机制是return，判断是否异常的方法就是返回值。方法根据是否异常返回不同的返回值，调用者根据不同返回值进行判断，并进行相应处理。每一层方法都需要对调用的方法的每个不同返回值进行检查和处理，程序的正常逻辑和异常逻辑混杂在一起，代码往往难以阅读理解和维护。另外，因为异常毕竟是少数情况，程序员经常偷懒，假定异常不会发生，而忽略对异常返回值的检查，降低了程序的可靠性。 在有了异常机制后，程序的正常逻辑与异常逻辑可以相分离，异常情况可以集中进行处理，异常还可以自动向上传递，不再需要每层方法都进行处理，异常也不再可能被自动忽略，从而，处理异常情况的代码可以大大减少，代码的可读性、可靠性、可维护性也都可以得到提高。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"函数调用基本原理","slug":"函数调用基本原理","date":"2018-06-06T10:00:42.000Z","updated":"2021-04-24T05:55:30.903Z","comments":true,"path":"2018/06/06/函数调用基本原理/","link":"","permalink":"http://example.com/2018/06/06/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/","excerpt":"","text":"如果需要经常做某一个操作，则类似的代码需要重复写很多遍，比如在一个数组中查找某个数，第一次查找一个数，第二次可能查找另一个数，每查一个数，类似的代码都需要重写一遍，很罗嗦。另外，有一些复杂的操作，可能分为很多个步骤，如果都放在一起，则代码难以理解和维护。 计算机程序使用函数这个概念来解决这个问题，即使用函数来减少重复代码和分解复杂操作，本文我们就来谈谈Java中的函数，包括函数的基础和调用原理等相关知识。 定义函数 函数的基本语法结构，即： 1234修饰符 返回值类型 函数名字(参数类型 参数名字, ...) &#123; 操作 ... return 返回值;&#125; 函数的主要组成部分有： 函数名字：名字是不可或缺的，表示函数的功能。 参数：参数有0个到多个，每个参数有参数的数据类型和参数名字组成。 操作：函数的具体操作代码。 返回值：函数可以没有返回值，没有的话返回值类型写成void，有的话在函数代码中必须要使用return语句返回一个值，这个值的类型需要和声明的返回值类型一致。 修饰符：Java中函数有很多修饰符，分别表示不同的目的，在本节我们假定修饰符为public static，且暂不讨论这些修饰符的目的。 以上就是定义函数的语法，定义函数就是定义了一段有着明确功能的子程序，但定义函数本身不会执行任何代码，函数要被执行，需要被调用。 函数调用Java中，任何函数都需要放在一个类中 ，Java中函数一般叫做方法，我们不特别区分函数和方法，可能会交替使用。一个类里面可以定义多个函数，类里面可以定义一个叫做main的函数，形式如： 123public static void main(String[] args) &#123; ...&#125; 这个函数有特殊的含义，表示程序的入口，String[] args表示从控制台接收到的参数。Java中运行一个程序的时候，需要指定一个定义了main函数的类，Java会寻找main函数，并从main函数开始执行。 刚开始学编程的人可能会误以为程序从代码的第一行开始执行，这是错误的，不管main函数定义在哪里，Java函数都会先找到它，然后从它的第一行开始执行。main函数中除了可以定义变量，操作数据 ，还可以调用其它函数 。 对于需要重复执行的代码，可以定义函数，然后在需要的地方调用，这样可以减少重复代码。对于复杂的操作，可以将操作分为多个函数，会使得代码更加易读。 程序执行基本上只有顺序执行、条件执行和循环执行，但更完整的描述应该包括函数的调用过程。程序从main函数开始执行，碰到函数调用的时候，会跳转进函数内部，函数调用了其他函数，会接着进入其他函数，函数返回后会继续执行调用后面的语句，返回到main函数并且main函数没有要执行的语句后程序结束。 在Java中，函数在程序代码中的位置和实际执行的顺序是没有关系的。 函数的定义和基本调用应该是比较容易理解的，但有很多细节可能令初学者困惑，包括参数传递、参数类型，返回、函数命名、调用过程等，我们逐个讨论下。 参数传递形参和实参形式参数：是在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传入的参数，简称“形参”。 实际参数：在主调函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”，简称“实参”。 举个栗子： 123456789101112public class ParamTest &#123; public static void main(String[] args) &#123; ParamTest pt = new ParamTest(); // 实际参数为“张三” pt.sout(&quot;张三&quot;); &#125; public void sout(String name) &#123; // 形式参数为 name System.out.print(name); &#125; &#125; 值传递和引用传递值传递：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。 引用传递：指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。 两者的区别： 值传递 引用传递 根本区别 会创建副本 不会创建副本 所以 函数中无法改变原始对象 函数中可以改变原始对象 那Java中使用的究竟是值传递还是引用传递呢？我们将在后面给出答案。 参数类型函数主要的参数类别又可分为基本类型参数，引用类型参数，数组参数和可变长度参数，以下我们逐个进行介绍。 基本类型参数基本类型参数很好理解，就是简单的值传递，直接将值复制到函数内部进行使用，基本类型不会对调用者中的变量造成任何影响 。 引用类型参数那引用类型参数是不是使用的引用传递呢？我们来看下面的栗子： 123456789101112131415161718192021222324252627282930313233343536373839404142public static void main(String[] args) &#123; User user = new User(); user.setName(&quot;张三&quot;); user.setAge(18); System.out.println(&quot;call方法调用前，user=&quot; + user.toString()); call(user); System.out.println(&quot;call方法调用后，user=&quot; + user.toString());&#125;public static void call(User user) &#123; user.setName(&quot;李四&quot;); System.out.println(&quot;call方法中,user = &quot; + user.toString());&#125;static class User &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 上面代码中，定义了一个User类，在main方法中，new了一个新的User对象user，然后给user对象的成员变量赋值，call方法中，修改了传入的user对象的属性。 运行main方法，结果如下： 123call方法调用前，user= User&#123;name=&#x27;张三&#x27;, age=18&#125;call方法中,user = User&#123;name=&#x27;李四&#x27;, age=18&#125;call方法调用后，user= User&#123;name=&#x27;李四&#x27;, age=18&#125; 引用类型参数与基本类型参数略有不同，但使用的仍然是值传递，只不过对于引用类型参数，值的内容是对象的引用。 就是在调用函数时只将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到调用者中的变量 在Java中，方法参数的传递不管是基本数据类型还是引用类型都是值传递 数组参数数组与引用参数类似，在函数内修改数组中的元素会修改调用者中的数组内容。我们看个例子： 12345678910111213public static void reset(int[] arr)&#123; for(int i=0;i&lt;arr.length;i++)&#123; arr[i] = i; &#125;&#125;public static void main(String[] args) &#123; int[] arr = &#123;10,20,30,40&#125;; reset(arr); for(int i=0;i&lt;arr.length;i++)&#123; System.out.println(arr[i]); &#125;&#125; 在reset函数内给参数数组元素赋值，在main函数中数组arr的值也会变。 这个其实也容易理解， 一个数组变量有两块空间，一块用于存储数组内容本身，另一块用于存储内容的位置，给数组变量赋值不会影响原有的数组内容本身，而只会让数组变量指向一个不同的数组内容空间，这一点与引用参数类似的。 在上例中，函数参数中的数组变量arr和main函数中的数组变量arr存储的都是相同的位置，而数组内容本身只有一份数据，所以，在reset中修改数组元素内容和在main中修改是完全一样的。 可变长度参数上面介绍的函数，参数个数都是固定的，但有的时候，可能希望参数个数不是固定的，比如说求若干个数的最大值，可能是两个，也可能是多个，Java支持可变长度的参数，如下例所示： 12345678910111213141516public static int max(int min, int ... a)&#123; int max = min; for(int i=0;i&lt;a.length;i++)&#123; if(max&lt;a[i])&#123; max = a[i]; &#125; &#125; return max;&#125;public static void main(String[] args) &#123; System.out.println(max(0)); System.out.println(max(0,2)); System.out.println(max(0,2,4)); System.out.println(max(0,2,4,5));&#125; 这个max函数接受一个最小值，以及可变长度的若干参数，返回其中的最大值。可变长度参数的语法是在数据类型后面加三个点…，在函数内，可变长度参数可以看做就是数组，可变长度参数必须是参数列表中的最后一个参数，一个函数也只能有一个可变长度的参数。 可变长度参数实际上会转换为数组参数，也就是说，函数声明max(int min, int… a)实际上会转换为 max(int min, int[] a)，在main函数调用 max(0,2,4,5)的时候，实际上会转换为调用 max(0, new int[]{2,4,5})，使用可变长度参数主要是简化了代码书写。 返回return的含义对初学者，我们强调下return的含义。 函数返回值类型为void且没有return的情况下，会执行到函数结尾自动返回。return用于结束函数执行，返回调用方。 return可以用于函数内的任意地方，可以在函数结尾，也可以在中间，可以在if语句内，可以在for循环内，用于提前结束函数执行，返回调用方。 函数返回值类型为void也可以使用return，即return;，不用带值，含义是返回调用方，只是没有返回值而已。 返回值的个数函数的返回值最多只能有一个，那如果实际情况需要多个返回值呢？比如说，计算一个整数数组中的最大的前三个数，需要返回三个结果。这个可以用数组作为返回值，在函数内创建一个包含三个元素的数组，然后将前三个结果赋给对应的数组元素。 如果实际情况需要的返回值是一种复合结果呢？比如说，查找一个字符数组中，所有重复出现的字符以及重复出现的次数。这个可以用对象作为返回值。 函数命名每个函数都有一个名字，这个名字表示这个函数的意义，名字可以重复吗？在不同的类里，答案是肯定的，在同一个类里，要看情况。 同一个类里，函数可以重名，但是参数不能一样，一样是指参数个数相同，每个位置的参数类型也一样，但参数的名字不算，返回值类型也不算。换句话说，函数的唯一性标示是：类名函数名_参数1类型_参数2类型…参数n类型。 同一个类中函数名字相同但参数不同的现象，一般称为函数重载。为什么需要函数重载呢？一般是因为函数想表达的意义是一样的，但参数个数或类型不一样。比如说，求两个数的最大值，在Java的Math库中就定义了四个函数，如下所示： 调用过程匹配过程在之前介绍函数调用的时候，我们没有特别说明参数的类型。这里说明一下，参数传递实际上是给参数赋值，调用者传递的数据需要与函数声明的参数类型是匹配的，但不要求完全一样。什么意思呢？Java编译器会自动进行类型转换，并寻找最匹配的函数。比如说： 123char a &#x3D; &#39;a&#39;;char b &#x3D; &#39;b&#39;;System.out.println(Math.max(a,b)); 参数是字符类型的，但Math并没有定义针对字符类型的max函数，我们之前说明，char其实是一个整数，Java会自动将char转换为int，然后调用Math.max(int a, int b)，屏幕会输出整数结果98。 如果Math中没有定义针对int类型的max函数呢？调用也会成功，会调用long类型的max函数，如果long也没有呢？会调用float型的max函数，如果float也没有，会调用double型的。Java编译器会自动寻找最匹配的。在只有一个函数的情况下（即没有重载），只要可以进行类型转换，就会调用该函数，在有函数重载的情况下，会调用最匹配的函数。 递归函数大部分情况下都是被别的函数调用，但其实函数也可以调用它自己，调用自己的函数就叫递归函数。 为什么需要自己调用自己呢？我们来看一个例子，求一个数的阶乘，数学中一个数n的阶乘，表示为n!，它的值定义是这样的： 120!&#x3D;1n!&#x3D;(n-1)!×n 0的阶乘是1，n的阶乘的值是n-1的阶乘的值乘以n，这个定义是一个递归的定义，为求n的值，需先求n-1的值，直到0，然后依次往回退。用递归表达的计算用递归函数容易实现，代码如下： 1234567public static long factorial(int n)&#123; if(n==0)&#123; return 1; &#125;else&#123; return n*factorial(n-1); &#125;&#125; 看上去应该是比较容易理解的，和数学定义类似。 递归函数形式上往往比较简单，但递归其实是有开销的，而且使用不当，可以会出现意外的结果，比如说这个调用： 1System.out.println(factorial(10000)); 系统并不会给出任何结果，而会抛出异常，异常我们在后续章节介绍，此处理解为系统错误就可以了，异常类型为：java.lang.StackOverflowError，这是什么意思呢？这表示栈溢出错误，要理解这个错误，我们需要理解函数调用的实现原理（下节介绍）。 那如果递归不行怎么办呢？递归函数经常可以转换为非递归的形式，通过一些数据结构（后续章节介绍）以及循环来实现。比如，求阶乘的例子，其非递归形式的定义是： 1n!&#x3D;1×2×3×…×n 这个可以用循环来实现，代码如下： 1234567public static long factorial(int n)&#123; long result = 1; for(int i=1; i&lt;=n; i++)&#123; result*=i; &#125; return result;&#125; 函数调用实现机制上面我们提到了一个系统异常java.lang.StackOverflowError，栈溢出错误，要理解这个错误，我们需要理解函数调用的实现机制。 栈程序从main函数开始顺序执行，函数调用可以看做是一个无条件跳转，跳转到对应函数的指令处开始执行，碰到return语句或者函数结尾的时候，再执行一次无条件跳转，跳转回调用方，执行调用函数后的下一条指令。 但这里面有几个问题： 参数如何传递？ 函数如何知道返回到什么地方？在if/else, for中，跳转的地址都是确定的，但函数自己并不知道会被谁调用，而且可能会被很多地方调用，它并不能提前知道执行结束后返回哪里。 函数结果如何传给调用方？ 解决思路是使用内存来存放这些数据，函数调用方和函数自己就如何存放和使用这些数据达成一个一致的协议或约定。这个约定在各种计算机系统中都是类似的，存放这些数据的内存有一个相同的名字，叫栈。 栈是一块内存，但它的使用有特别的约定，一般是先进后出，类似于一个桶，往栈里放数据，我们称为入栈，最下面的我们称为栈底，最上面的我们称为栈顶，从栈顶拿出数据，通常称为出栈。栈一般是从高位地址向低位地址扩展，换句话说，栈底的内存地址是最高的，栈顶的是最小的。 计算机系统主要使用栈来存放函数调用过程中需要的数据，包括参数、返回地址，函数内定义的局部变量也放在栈中。计算机系统就如何在栈中存放这些数据，调用者和函数如何协作做了约定。返回值不太一样，它可能放在栈中，但它使用的栈和局部变量不完全一样，有的系统使用CPU内的一个存储器存储返回值，我们可以简单认为存在一个专门的返回值存储器。 main函数的相关数据放在栈的最下面，每调用一次函数，都会将相关函数的数据入栈，调用结束会出栈。 以上描述可能有点抽象，我们通过一个例子来说明： 12345678910111213public class Sum &#123; 2 3 public static int sum(int a, int b) &#123; 4 int c = a + b; 5 return c; 6 &#125; 7 8 public static void main(String[] args) &#123; 9 int d = Sum.sum(1, 2);10 System.out.println(d);11 &#125;12 13 &#125; 这是一个简单的例子，main函数调用了sum函数，计算1和2的和，然后输出计算结果，从概念上，这是容易理解的，让我们从栈的角度来讨论下。 当程序在main函数调用Sum.sum之前，栈的情况大概是这样的： 主要存放了两个变量args和d。在程序执行到Sum.sum的函数内部，准备返回之前，即第5行，栈的情况大概是这样的： 我们解释下，在main函数调用Sum.sum时，首先将参数1和2入栈，然后将返回地址（也就是调用函数结束后要执行的指令地址）入栈，接着跳转到sum 函数，在sum函数内部，需要为局部变量c分配一个空间，而参数变量a和b则直接对应于入栈的数据1和2，在返回之前，返回值保存到了专门的返回值存储器 中。 在调用return后，程序会跳转到栈中保存的返回地址，即main的下一条指令地址，而sum函数相关的数据会出栈，从而又变回下面这样： main的下一条指令是根据函数返回值给变量d赋值，返回值从专门的返回值存储器中获得。 函数执行的基本原理，简单来说就是这样。但有一些需要介绍的点，我们讨论一下。 变量生命周期定义一个变量就会分配一块内存，但我们并没有具体谈什么时候分配内存，具体分配在哪里，什么时候释放内存。 从以上关于栈的描述我们可以看出，函数中的参数和函数内定义的变量，都分配在栈中，这些变量只有在函数被调用的时候才分配，而且在调用结束后就被释放了。但这个说法主要针对基本数据类型，接下来我们谈数组和对象。 数组和对象对于数组和对象类型，我们介绍过，它们都有两块内存，一块存放实际的内容，一块存放实际内容的地址，实际的内容空间一般不是分配在栈上的，而是分配在堆（也是内存的一部分，后续文章介绍）中，但存放地址的空间是分配在栈上的。 我们来看个例子，下面是代码： 12345678910111213141516171819public class ArrayMax &#123; public static int max(int min, int[] arr) &#123; int max = min; for(int a : arr)&#123; if(a&gt;max)&#123; max = a; &#125; &#125; return max; &#125; public static void main(String[] args) &#123; int[] arr = new int[]&#123;2,3,4&#125;; int ret = max(0, arr); System.out.println(ret); &#125;&#125; 这个程序也很简单，main函数新建了一个数组，然后调用函数max计算0和数组中元素的最大值，在程序执行到max函数的return语句之前的时候，内存中栈和堆的情况大概是这样的： 对于数组arr，在栈中存放的是实际内容的地址0x1000，存放地址的栈空间会随着入栈分配，出栈释放，但存放实际内容的堆空间不受影响。 但说堆空间完全不受影响是不正确的，在这个例子中，当main函数执行结束，栈空间没有变量指向它的时候，Java系统会自动进行垃圾回收，从而释放这块空间。 递归调用 我们再通过栈的角度来理解一下递归函数的调用过程，代码如下： 123456789101112public static int factorial(int n) &#123; if(n==0)&#123; return 1; &#125;else&#123; return n*factorial(n-1); &#125;&#125;public static void main(String[] args) &#123; int ret = factorial(4); System.out.println(ret);&#125; 在factorial第一次被调用的时候，n是4，在执行到 nfactorial(n-1)，即4factorial(3)之前的时候，栈的情况大概是： 注意返回值存储器是没有值的，在调用factorial(3)后，栈的情况变为了： 栈的深度增加了，返回值存储器依然为空，就这样，每递归调用一次，栈的深度就增加一层，每次调用都会分配对应的参数和局部变量，也都会保存调用的返回地址，在调用到n等于0的时候，栈的情况是： 这个时候，终于有返回值了，我们将factorial简写为f。f(0)的返回值为1，f(0)返回到f(1)，f(1)执行1f(0)，结果也是1，然 后返回到f(2)，f(2)执行2f(1)，结果是2，然后接着返回到f(3)，f(3)执行3f(2)，结果是6，然后返回到f(4)，执行 4f(3)，结果是24。 以上就是递归函数的执行过程，函数代码虽然只有一份，但在执行的过程中，每调用一次，就会有一次入栈，生成一份不同的参数、局部变量和返回地址。 函数调用成本从函数调用的过程我们可以看出，调用是有成本的，每一次调用都需要分配额外的栈空间用于存储参数、局部变量以及返回地址，需要进行额外的入栈和出栈操作。 在递归调用的情况下，如果递归的次数比较多，这个成本是比较可观的，所以，如果程序可以比较容易的改为别的方式，应该考虑别的方式。 另外，栈的空间不是无限的，一般正常调用都是没有问题的，但像上节介绍的例子，栈空间过深，系统就会抛出错误，java.lang.StackOverflowError，即栈溢出。 小结函数是计算机程序的一种重要结构，通过函数来减少重复代码，分解复杂操作是计算机程序的一种重要思维方式。 本文我们介绍了函数的基础概念，还有关于参数传递、返回值、重载、递归方面和调用实现机制上的一些细节 。 函数调用主要是通过栈来存储相关数据的，系统就函数调用者和函数如何使用栈做了约定，返回值我们简化认为是通过一个专门的返回值存储器存储的，我们主要从概念上介绍了其基本原理。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"剖析String","slug":"剖析String","date":"2018-06-05T14:09:37.000Z","updated":"2020-04-12T15:14:35.944Z","comments":true,"path":"2018/06/05/剖析String/","link":"","permalink":"http://example.com/2018/06/05/%E5%89%96%E6%9E%90String/","excerpt":"","text":"基本用法Java中表示字符串的类是String，首先我们来介绍下Java中字符串的基本用法。 可以通过常量定义String变量 1String name = &quot;hello 世界！&quot;; 也可以通过new创建String 1String name = new String(&quot;hello 世界！&quot;); String可以直接使用+和+=运算符，如： 1234String name = &quot;hello&quot;;name += &quot;世界！&quot;;String test = &quot;你好！&quot;;System.out.println(name + test); 输出为：hello 世界！你好！ String类中还包括很多方法，以方便操作字符串，以下是一些常用的方法。 比如判断字符串是否为空，但这不包含为null的情况 1public boolean isEmpty() 判断一个字符串为null或为空字符串，我们一般这样自定义实现 123public boolean isBlank(String str) &#123; return str == null || str.isEmpty();&#125; 获取字符串长度 1public int length() 取子字符串 12public String substring(int beginIndex)public String substring(int beginIndex, int endIndex) 在字符串中查找字符或子字符串，返回第一个找到的索引位置，没找到返回-1 12public int indexOf(int ch)public int indexOf(String str) 从后面查找字符或子字符串，返回从后面数的第一个索引位置，没找到返回-1 12public int lastIndexOf(int ch)public int lastIndexOf(String str) 判断字符串中是否包含指定的字符序列。CharSequence是一个接口，表示一个字符序列，String也实现了CharSequence 1public boolean contains(CharSequence s) 判断字符串是否以给定子字符串开头 1public boolean startsWith(String prefix) 判断字符串是否以给定子字符串结尾 1public boolean endsWith(String suffix) 与其他字符串比较，看内容是否相同 1public boolean equals(Object anObject) 忽略大小写，与其他字符串进行比较，看内容是否相同 1public boolean equalsIgnoreCase(String anotherString) String也实现了Comparable接口，可以比较字符串大小 1public int compareTo(String anotherString) 还可以忽略大小写，进行大小比较 1public int compareToIgnoreCase(String str) 所有字符转换为大写字符，返回新字符串，原字符串不变 12public String toUpperCase()public String toUpperCase(Locale locale) 所有字符转换为小写字符，返回新字符串，原字符串不变 12public String toLowerCase()public String toLowerCase(Locale locale) 当你的程序在涉及国际化的情况下请务必指定locale，如：Locale.ENGLISH，不然在不同语言的机器上转换结果可能会不一致。 字符串连接，返回当前字符串和参数字符串合并后的字符串，原字符串不变 1public String concat(String str) 字符串替换，替换单个字符，返回新字符串，原字符串不变 1public String replace(char oldChar, char newChar) 字符串替换，替换字符序列，返回新字符串，原字符串不变 1public String replace(CharSequence target, CharSequence replacement) 删掉开头和结尾的空格，返回新字符串，原字符串不变 1public String trim() 分隔字符串，返回分隔后的子字符串数组，原字符串不变 1public String[] split(String regex) 注意这里参数是一个正则表达式，比如要按“.”号分割的话（“.”在正则表达式中有特殊含义），需按如下方式写 123String str = &quot;aa.bbb.cc&quot;;String[] arr = str.split(&quot;[.]&quot;);System.out.println(arr.length); 剖析String内部实现从调用者的角度理解了String的基本用法，下面我们进一步来理解String的内部。 封装字符数组 String类内部封装了一个字符数组表示字符串，实例变量定义为： 1private final char value[]; String有两个构造方法，可以根据char数组创建String 12public String(char value[])public String(char value[], int offset, int count) 需要说明的是，String会根据参数新创建一个数组，并拷贝内容，而不会直接用参数中的字符数组。 String中的大部分方法，内部也都是操作的这个字符数组。比如说： length()方法返回的就是这个数组的长度 substring()方法就是根据参数，调用构造方法String(char value[], int offset, int count)新建了一个字符串 indexOf查找字符或子字符串时就是在这个数组中进行查找 String中还有一些方法，与这个char数组有关： 1public char charAt(int index) 返回字符串对应的char数组 1public char[] toCharArray() 注意，这里返回的是一个拷贝后的数组，而不是原数组。 将char数组中指定范围的字符拷贝入目标数组指定位置 1public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) 编码转换 String内部是按UTF-16BE处理字符的，对BMP字符，使用一个char，两个字节，对于增补字符，使用两个char，四个字节。我们之前介绍过各种编码，不同编码可能用于不同的字符集，使用不同的字节数目，和不同的二进制表示。如何处理这些不同的编码呢？这些编码与Java内部表示之间如何相互转换呢？ Java使用Charset这个类表示各种编码，它有两个常用静态方法： 12public static Charset defaultCharset()public static Charset forName(String charsetName) 第一个方法返回系统的默认编码，比如，在我的电脑上，执行如下语句： 1System.out.println(Charset.defaultCharset().name()); // 输出为UTF-8 第二方法返回给定编码名称的Charset对象，与我们在第六节介绍的编码相对应，其charset名称可以是:US-ASCII, ISO-8859-1, windows-1252, GB2312, GBK, GB18030, Big5, UTF-8，比如： 1Charset charset = Charset.forName(&quot;GB18030&quot;); String类提供了如下方法，返回字符串按给定编码的字节表示： 123public byte[] getBytes()public byte[] getBytes(String charsetName)public byte[] getBytes(Charset charset) 第一个方法没有编码参数，使用系统默认编码，第二方法参数为编码名称，第三个为Charset。 String类有如下构造方法，可以根据字节和编码创建字符串，也就是说，根据给定编码的字节表示，创建Java的内部表示。 123456public String(byte bytes[])public String(byte bytes[], int offset, int length)public String(byte bytes[], int offset, int length, String charsetName)public String(byte bytes[], int offset, int length, Charset charset)public String(byte bytes[], String charsetName)public String(byte bytes[], Charset charset) 除了通过String中的方法进行编码转换，Charset类中也有一些方法进行编码/解码，这里就不介绍了。重要的是认识到，Java的内部表示与各种编码是不同的，但可以相互转换。 不可变性 与包装类类似，String类也是不可变类，即对象一旦创建，就没有办法修改了。String类也声明为了final，不能被继承，内部char数组value也是final的，初始化后就不能再变了。 String类中提供了很多看似修改的方法，其实是通过创建新的String对象来实现的，原来的String对象不会被修改。比如说，我们来看concat()方法的代码： 12345678910public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; int len = value.length; char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len); return new String(buf, true);&#125; 通过Arrays.copyOf方法创建了一块新的字符数组，拷贝原内容，然后通过new创建了一个新的String。 与包装类类似，定义为不可变类，程序可以更为简单、安全、容易理解。但如果频繁修改字符串，而每次修改都新建一个字符串，性能太低，这时，应该考虑Java中的另两个类StringBuilder和StringBuffer。 常量字符串 Java中的字符串常量是非常特殊的，除了可以直接赋值给String变量外，它自己就像一个String类型的对象一样，可以直接调用String的各种方法。我们来看代码： 123System.out.println(&quot;hello world&quot;.length());System.out.println(&quot;老hello&quot;.contains(&quot;world&quot;));System.out.println(&quot;hello&quot;.indexOf(&quot;el&quot;)); 实际上，这些常量就是String类型的对象，在内存中，它们被放在一个共享的地方，这个地方称为字符串常量池，它保存所有的常量字符串，每个常量只会保存一份，被所有使用者共享。当通过常量的形式使用一个字符串的时候，使用的就是常量池中的那个对应的String类型的对象。 比如说，我们来看代码： 1234String nihao = new String(new char[]&#123;&#x27;你&#x27;,&#x27;好&#x27;,&#x27;世&#x27;,&#x27;界&#x27;&#125;);String name1 = nihao;String name2 = nihao;System.out.println(name1==name2); 实际上只有一个String对象，三个变量都指向这个对象，name1==name2也就不言而喻了。 需要注意的是，如果不是通过常量直接赋值，而是通过new创建的，==就不会返回true了，看下面代码： 123String name1 = new String(&quot;你好世界&quot;);String name2 = new String(&quot;你好世界&quot;);System.out.println(name1==name2); 输出为false，为什么呢？上面代码类似于： 123String name1 = new String(nihao);String name2 = new String(nihao);System.out.println(name1==name2); String类中以String为参数的构造方法代码如下： 1234public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125; hash是String类中另一个实例变量，表示缓存的hashCode值，我们待会介绍。可以看出, name1和name2指向两个不同的String对象，只是这两个对象内部的value值指向相同的char数组。 所以，name1==name2是不成立的，但name1.equals(name2)是true。 hashCode 我们刚刚提到hash这个实例变量，它的定义如下： 1private int hash; // Default to 0 它缓存了hashCode()方法的值，也就是说，第一次调用hashCode()的时候，会把结果保存在hash这个变量中，以后再调用就直接返回保存的值。 我们来看下String类的hashCode方法，代码如下： 123456789101112public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; 如果缓存的hash不为0，就直接返回了，否则根据字符数组中的内容计算hash，计算方法是：s[0]*31^(n-1) + s[1]*31^(n-2) + … + s[n-1] s表示字符串，s[0]表示第一个字符，n表示字符串长度，s[0]*31^(n-1)表示31的n-1次方再乘以第一个字符的值。 为什么要用这个计算方法呢？这个式子中，hash值与每个字符的值有关，每个位置乘以不同的值，hash值与每个字符的位置也有关。使用31大概是因为两个原因，一方面可以产生更分散的散列，即不同字符串hash值也一般不同，另一方面计算效率比较高，31h与32h-h即 (h&lt;&lt;5)-h等价，可以用更高效率的移位和减法操作代替乘法操作。 在Java中，普遍采用以上思路来实现hashCode。 正则表达式 String类中，有一些方法接受的不是普通的字符串参数，而是正则表达式，什么是正则表达式呢？它可以理解为一个字符串，但表达的是一个规则，一般用于文本的匹配、查找、替换等，正则表达式有着丰富和强大的功能，是一个比较庞大的话题，我们可能会在后续章节单独介绍。 Java中有专门的类如Pattern和Matcher用于正则表达式，但对于简单的情况，String类提供了更为简洁的操作，String中接受正则表达式的方法有： 分隔字符串 1public String[] split(String regex) 检查是否匹配 1public boolean matches(String regex) 字符串替换 12public String replaceFirst(String regex, String replacement)public String replaceAll(String regex, String replacement) 小结本节，我们介绍了String类，介绍了其基本用法，内部实现，编码转换，分析了其不可变性，常量字符串，以及hashCode的实现。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Char的本质是什么","slug":"Char的本质是什么","date":"2018-05-11T14:09:37.000Z","updated":"2021-04-23T09:00:08.031Z","comments":true,"path":"2018/05/11/Char的本质是什么/","link":"","permalink":"http://example.com/2018/05/11/Char%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88/","excerpt":"","text":"本节讨论在Java中进行字符处理的基础 - char，Java中还有Character, String, StringBuffer, StringBuilder等类进行文本处理，他们的基础都是char，我们在后续文章中介绍这些类。 char的本质char看上去是很简单的，正如我们之前所说，char用于表示一个字符，这个字符可以是中文字符，也可以是英文字符。赋值时把常量字符用单引号括起来，例如： 12char c = &#x27;A&#x27;;char z = &#x27;中&#x27;; 但为什么字符类型也可以进行算术运算和比较？char的本质到底是什么呢？ 在 Java内部进行字符处理时，采用的都是Unicode，具体编码格式是UTF-16BE。UTF-16使用两个或四个字节表示一个字符，Unicode编号范围在65536以内的占两个字节，超出范围的占四个字节，BE (Big Endian)就是先输出高位字节，再输出低位字节，这与整数的内存表示是一致的。 因此，char本质上是一个固定占用两个字节的无符号正整数，这个正整数对应于Unicode编号，用于表示那个Unicode编号对应的字符。 由于固定占用两个字节，char只能表示Unicode编号在65536以内的字符，而不能表示超出范围的字符。 那超出范围的字符怎么表示呢？使用两个char。类String有一些相关的方法，我们后续会介绍。 在这个认识的基础上，我们再来看下char的一些行为，就比较容易理解了。 char的赋值char有多种赋值方式： 12345char c = &#x27;A&#x27; // 1char c = &#x27;马&#x27; // 2char c = 39532 // 3char c = 0x9a6c // 4char c = &#x27;\\u9a6c&#x27; // 5 第1种赋值方式是最常见的，将一个能用Ascii码表示的字符赋给一个字符变量。 第 2种也很常见，但这里是个中文字符，需要注意的是，直接写字符常量的时候应该注意文件的编码，比如说，GBK编码的代码文件按UTF-8打开，字符会变成乱码，赋值的时候是按当前的编码解读方式，将这个字符形式对应的Unicode编号值赋给变量，’马’对应的Unicode编号是39532，所以第2种赋值和第3种是一样的。 第3种是直接将十进制的常量赋给字符。 第4种是将16进制常量赋给字符。 第5种是按Unicode字符形式。 以上，2，3，4，5都是一样的，本质都是将Unicode编号39532赋给了字符。 char的运算由于char本质上是一个整数，所以可以进行整数可以进行的一些运算，在进行运算时会被看做int，但由于char占两个字节，运算结果不能直接赋值给char类型，需要进行强制类型转换，这和byte, short参与整数运算是类似的。 char类型的比较就是其Unicode编号的比较。 char 的加减运算就是按其Unicode编号进行运算，一般对字符做加减运算没什么意义，但Ascii码字符是有意义的。比如大小写转换，大写A-Z的编号是 65-90，小写a-z的编号是97-122，正好相差32，所以大写转小写只需加32，而小写转大写只需减32。加减运算的另一个应用是加密和解密，将 字符进行某种可逆的数学运算可以做加解密。 char的位运算可以看做就是对应整数的位运算，只是它是无符号数，也就是说，有符号右移&gt;&gt;和无符号右移&gt;&gt;&gt;的结果是一样的。 char的二进制既然char本质上是整数，查看char的二进制表示，同样可以用Integer的方法，如下所示： 12char c = &#x27;马&#x27;;System.out.println(Integer.toBinaryString(c)); 输出为 1001101001101100 小结本节介绍了char的本质，它固定占用两个字节，实际上是一个整数，表示字符的Unicode编号，不在65536编号内的字符一个char表示不了，需要用两个char。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"编码与乱码","slug":"编码与乱码","date":"2018-05-06T14:09:37.000Z","updated":"2020-04-01T15:39:15.014Z","comments":true,"path":"2018/05/06/编码与乱码/","link":"","permalink":"http://example.com/2018/05/06/%E7%BC%96%E7%A0%81%E4%B8%8E%E4%B9%B1%E7%A0%81/","excerpt":"","text":"编码ASCII世界上虽然有各种各样的字符，但计算机发明之初没有考虑那么多，基本上只考虑了美国的需求，美国大概只需要128个字符，美国就规定了这128个字符的二进制表示方法。这个方法是一个标准，称为ASCII编码，全称是American Standard Code for Information Interchange，美国信息互换标准代码。 128个字符用7个位刚好可以表示，计算机存储的最小单位是byte，即8位，ASCII码中最高位设置为0，用剩下的7位表示字符。这7位可以看做数字0到127，ASCII码规定了从0到127个，每个数字代表什么含义。 数字32到126表示的这些字符都是可打印字符，0到31和127表示一些不可以打印的字符，这些字符一般用于控制目的，这些字符中大部分都是不常用的，下表列出了其中相对常用的字符。 数字 缩写 解释 转义字符 0 NUL 空字符 \\0 8 BS 退格 \\b 9 HT 水平制表符 \\t 10 LF 换行符 \\n 13 CR 回车键 \\r 27 ESC 换码 127 DEL 删除 Ascii 码对美国是够用了，但对别的国家而言却是不够的，于是，各个国家的各种计算机厂商就发明了各种各种的编码方式以表示自己国家的字符，为了保持与Ascii 码的兼容性，一般都是将最高位设置为1。也就是说，当最高位为0时，表示Ascii码，当为1时就是各个国家自己的字符。 在这些扩展的编码中，在西欧国家中流行的是ISO 8859-1和Windows-1252，在中国是GB2312，GBK，GB18030和Big5，我们逐个来看下这些编码。 ISO 8859-1ISO 8859-1又称Latin-1，它也是使用一个字节表示一个字符，其中0到127与Ascii一样，128到255规定了不同的含义。 在128到255中，128到159表示一些控制字符，这些字符也不常用，就不介绍了。 Windows-1252ISO 8859-1虽然号称是标准，用于西欧国家，但它连欧元(€) 这个符号都没有，因为欧元比较晚，而标准比较早。实际使用中更为广泛的是Windows-1252编码，这个编码与ISO8859-1基本是一样的，区别只在于数字128到159，Windows-1252使用其中的一些数字表示可打印字符。 ISO 8859-1基本已被Windows-1252取代，在很多应用程序中，即使文件声明它采用的是ISO 8859-1编码，解析的时候依然被当做Windows-1252编码。 HTML5 甚至明确规定，如果文件声明的是ISO 8859-1编码，它应该被看做Windows-1252编码。为什么要这样呢？因为大部分人搞不清楚ISO 8859-1和Windows-1252的区别，当他说ISO 8859-1的时候，其实他实际指的是Windows-1252，所以标准干脆就这么强制了。 GB2312美国和西欧字符用一个字节就够了，但中文显然是不够的。中文第一个标准是GB2312。 GB2312标准主要针对的是简体中文常见字符，包括约7000个汉字，不包括一些罕用词，不包括繁体字。 GB2312固定使用两个字节表示汉字，在这两个字节中，最高位都是1，如果是0，就认为是Ascii字符。在这两个字节中，其中高位字节范围是0xA1-0xF7，低位字节范围是0xA1-0xFE。 GBKGBK建立在GB2312的基础上，向下兼容GB2312，也就是说，GB2312编码的字符和二进制表示，在GBK编码里是完全一样的。 GBK增加了一万四千多个汉字，共计约21000汉字，其中包括繁体字。 GBK同样使用固定的两个字节表示，其中高位字节范围是0x81-0xFE，低位字节范围是0x40-0x7E和0x80-0xFE。 需要注意的是，低位字节是从0x40也就是64开始的，也就是说，低位字节最高位可能为0。那怎么知道它是汉字的一部分，还是一个Ascii字符呢？ 其实很简单，因为汉字是用固定两个字节表示的，在解析二进制流的时候，如果第一个字节的最高位为1，那么就将下一个字节读进来一起解析为一个汉字，而不用考虑它的最高位，解析完后，跳到第三个字节继续解析。 GB18030GB18030向下兼容GBK，增加了五万五千多个字符，共七万六千多个字符。包括了很多少数民族字符，以及中日韩统一字符。 用两个字节已经表示不了GB18030中的所有字符，GB18030使用变长编码，有的字符是两个字节，有的是四个字节。 在两字节编码中，字节表示范围与GBK一样。在四字节编码中，第一个字节的值从0x81到0xFE，第二个字节的值从0x30到0x39，第三个字节的值从0x81到0xFE，第四个字节的值从0x30到0x39。 解析二进制时，如何知道是两个字节还是四个字节表示一个字符呢？看第二个字节的范围，如果是0x30到0x39就是四个字节表示，因为两个字节编码中第二字节都比这个大。 Big5Big5是针对繁体中文的，广泛用于台湾香港等地。 Big5包括1万3千多个繁体字，和GB2312类似，一个字符同样固定使用两个字节表示。在这两个字节中，高位字节范围是0x81-0xFE，低位字节范围是0x40-0x7E和0xA1-0xFE。 编码总结我们简单总结一下上面的内容。 Ascii码是基础，一个字节表示，最高位设为0，其他7位表示128个字符。其他编码都是兼容Ascii的，最高位使用1来进行区分。 西欧主要使用Windows-1252，使用一个字节，增加了额外128个字符。 中文大陆地区的三个主要编码GB2312，GBK，GB18030，有时间先后关系，表示的字符数越来越多，且后面的兼容前面的，GB2312和GBK都是用两个字节表示，而GB18030则使用两个或四个字节表示。 香港台湾地区的主要编码是Big5。 如果文本里的字符都是Ascii码字符，那么采用以上所说的任一编码方式都是一一样的。 但如果有高位为1的字符，除了GB2312/GBK/GB18030外，其他编码都是不兼容的，比如，Windows-1252和中文的各种编码是不兼容的，即使Big5和GB18030都能表示繁体字，其表示方式也是不一样的，而这就会出现所谓的乱码。 为什么会出现乱码一个法国人，采用Windows-1252编码写了个文件，发送给了一个中国人，中国人使用GB18030来解析这个字符，看到的就是乱码，我们举个例子： 法 国人发送的是 “Pékin”，Windows-1252的二进制是（采用16进制）：50 E9 6B 69 6E，第二个字节E9对应é，其他都是Ascii码，中国人收到的也是这个二进制，但是他把它看做成了GB18030编码，GB18030中E9 6B对应的是字符”閗i”，于是他看到的就是：”P閗in”，这看来就是一个乱码。 反之也是一样的，一个GB18030编码的文件如果被看做Windows-1252也是乱码。 这 种情况下，之所以看起来是乱码，是因为看待或者说解析数据的方式错了。纠正的方式，只要使用正确的编码方式进行解读就可以了。很多文件编辑器，如 EditPlus, NotePad++, UltraEdit都有切换查看编码方式的功能，浏览器也都有切换查看编码方式的功能，如Firefox，在菜单 “查看”-&gt;”文字编码”中。 切换查看编码的方式，并没有改变数据的二进制本身，而只是改变了解析数据的方式，从而改变了数据看起来的样子。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"小数计算为什么不精确","slug":"小数计算为什么不精确","date":"2018-05-02T14:09:37.000Z","updated":"2020-04-01T15:19:25.032Z","comments":true,"path":"2018/05/02/小数计算为什么不精确/","link":"","permalink":"http://example.com/2018/05/02/%E5%B0%8F%E6%95%B0%E8%AE%A1%E7%AE%97%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%B2%BE%E7%A1%AE/","excerpt":"","text":"违反直觉计算机之所以叫”计算”机就是因为发明它主要是用来计算的，”计算”当然是它的特长，在大家的印象中，计算一定是非常准确的。但实际上，即使在一些非常基本的小数运算中，计算的结果也是不精确的。 比如： 12float f = 0.1f*0.1f;System.out.println(f); 这个结果看上去，不言而喻，应该是0.01，但实际上，屏幕输出却是0.010000001，后面多了个1。 看上去这么简单的运算，计算机怎么会出错了呢？ 为什么会出错呢？实际上，不是运算本身会出错，而是计算机根本就不能精确的表示很多数，比如0.1这个数。 计算机是用一种二进制格式存储小数的，这个二进制格式不能精确表示0.1，它只能表示一个非常接近0.1但又不等于0.1的一个数。 数字都不能精确表示，在不精确数字上的运算结果不精确也就不足为奇了。 0.1怎么会不能精确表示呢？在十进制的世界里是可以的，但在二进制的世界里不行。在说二进制之前，我们先来看下熟悉的十进制。 实际上，十进制也只能表示那些可以表述为10的多少次方和的数，比如12.345，实际上表示的：110+21+30.1+40.01+5*0.001，与整数的表示类似，小数点后面的每个位置也都有一个位权，从左到右，依次为 0.1,0.01,0.001,…即10^(-1), 10^(-2), 10^(-3)。 很多数，十进制也是不能精确表示的，比如1/3, 保留三位小数的话，十进制表示是0.333，但无论后面保留多少位小数，都是不精确的，用0.333进行运算，比如乘以3，期望结果是1，但实际上却是0.999。 二进制是类似的，但二进制只能表示哪些可以表述为2的多少次方和的数，来看下2的次方的一些例子： 2的次方 十进制 2^(-1) 0.5 2^(-2) 0.25 2^(-3) 0.125 2^(-4) 0.0625 因此只可以精确表示为2的某次方之和的数，其他数则不能精确表示。 为什么一定要用二进制呢？为什么就不能用我们熟悉的十进制呢？在最最底层，计算机使用的电子元器件只能表示两个状态，通常是低压和高压，对应0和1，使用二进制容易基于这些电子器件构建硬件设备和进行运算。如果非要使用十进制，则这些硬件就会复杂很多，并且效率低下。 为什么有的小数计算是准确的？如果你编写程序进行试验，你会发现有的计算结果是准确的。比如，我用Java写： 12System.out.println(0.1f + 0.1f);System.out.println(0.1f * 0.1f); 第一行输出0.2，第二行输出0.010000001。按照上面的说法，第一行的结果应该也不对啊？ 其实，这只是Java语言给我们造成的假象，计算结果其实也是不精确的，但是由于结果和0.2足够接近，在输出的时候，Java选择了输出0.2这个看上去非常精简的数字，而不是一个中间有很多0的小数。 在误差足够小的时候，结果看上去是精确的，但不精确才是常态。 怎么处理计算不精确计算不精确，怎么办呢？ 减小精度。大部分情况下，我们不需要那么高的精度，可以四舍五入，或者在输出的时候只保留固定个数的小数位。 进行转换。如果真的需要比较高的精度，可以将小数转化为整数进行运算，运算结束后再转化为小数。 使用十进制的数据类型。这个没有统一的规范，在Java中是用BigDecimal，运算更准确，但效率比较低。 小结小数计算为什么会出错呢？ 理由就是：很多小数计算机中不能精确表示，通常只可以精确表示为2的某次方之和的数，其他数则不能精确表示。计算机的基本思维是二进制的，所以，意料之外，情理之中吧。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"整数的二进制表示和位运算","slug":"整数的二进制表示和位运算","date":"2018-04-08T14:09:37.000Z","updated":"2020-04-01T14:56:28.831Z","comments":true,"path":"2018/04/08/整数的二进制表示和位运算/","link":"","permalink":"http://example.com/2018/04/08/%E6%95%B4%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"上节我们提到正整数相乘的结果居然出现了负数，要理解这个行为，我们需要看下整数在计算机内部的二进制表示。 十进制要理解二进制，我们先来看下熟悉的十进制。十进制是如此的熟悉，我们可能已忽略了它的含义。比如123，我们不假思索就知道它的值是多少。 但其实123表示的1*(10^2) + 2*(10^1) + 3*(10^0)，(10^2表示10的二次方)，它表示的是各个位置数字含义之和，每个位置的数字含义与位置有关，从右向左，第一位乘以10的0次方， 即1，第二位乘以10的1次方，即10，第三位乘以10的2次方，即100，依次类推。 换句话说，每个位置都有一个位权，从右到左，第一位为1，然后依次乘以10，即第二位为10，第三位为100，依次类推。 二进制正整数的二进制表示正整数的二进制表示与此类似， 只是在十进制中，每个位置可以有10个数字，从0到9，但在二进制中，每个位置只能是0或1。位权的概念是类似的，从右到左，第一位为1，然后依次乘以2，即第二位为2，第三位为4，依次类推。 看一些数字的例子吧 二进制 十进制 10 2 11 3 111 7 1010 10 负整数的二进制表示十进制的负数表示就是在前面加一个负数符号-，例如-123。但二进制如何表示负数呢？ 其实概念是类似的，二进制使用最高位表示符号位，用1表示负数，用0表示正数。 但哪个是最高位呢？整数有四种类型，byte/short/int/long，分别占1/2/4/8个字节，即分别占8/16/32/64位，每种类型的符号位都是其最左边的一位。 为方便举例，下面假定类型是byte，即从右到左的第8位表示符号位。 但负数表示不是简单的将最高位变为1，比如说： byte a = -1，如果只是将最高位变为1，二进制应该是10000001，但实际上，它应该是11111111。 byte a=-127，如果只是将最高位变为1，二进制应该是11111111，但实际上，它却应该是10000001。 和我们的直觉正好相反，这是什么表示法？这种表示法称为补码表示法，而符合我们直觉的表示称为原码表示法，补码表示就是在原码表示的基础上取反然后加1。取反就是将0变为1，1变为0。 负数的二进制表示就是对应的正数的补码表示，比如说： -1：1的原码表示是00000001，取反是11111110，然后再加1，就是11111111。 -2：2的原码表示是00000010，取反是11111101，然后再加1，就是11111110。 -127：127的原码表示是01111111，取反是10000000，然后再加1，就是10000001。 给定一个负数二进制表示，要想知道它的十进制值，可以采用相同的补码运算。比如：10010010，首先取反，变为01101101，然后加1，结果为01101110，它的十进制值为110，所以原值就是-110。直觉上，应该是先减1，然后再取反，但计算机只能做加法，而补码的一个良好特性就是，对负数的补码表示做补码运算就可以得到其对应整数的原码，正如十进制运算中负负得正一样。 byte类型，正数最大表示是01111111，即127，负数最小表示（绝对值最大）是10000000，即-128，表示范围就是 -128到127。其他类型的整数也类似，负数能多表示一个数。 负整数为什么采用补码呢？ 负整数为什么要采用这种奇怪的表示形式呢？原因是：只有这种形式，计算机才能实现正确的加减法。 计算机其实只能做加法，1-1其实是1+(-1)。如果用原码表示，计算结果是不对的。比如说： 1234 1 -&gt; 00000001-1 -&gt; 10000001+ -------------------2 -&gt; 10000010 用符合直觉的原码表示，1-1的结果是-2。 如果是补码表示： 1234 1 -&gt; 00000001-1 -&gt; 11111111+ ------------------ 0 -&gt; 00000000 结果是正确的。 再比如，5-3： 1234 5 -&gt; 00000101-3 -&gt; 11111101+ ------------------ 2 -&gt; 00000010 结果也是正确的。 就是这样的，看上去可能比较奇怪和难以理解，但这种表示其实是非常严谨和正确的，是不是很奇妙？ 理解了二进制加减法，我们就能理解为什么正数的运算结果可能出现负数了。当计算结果超出表示范围的时候，最高位往往是1，然后就会被看做负数。比如说，127+1： 1234127 -&gt; 011111111 -&gt; 00000001+ -------------------128 -&gt; 10000000 计算结果超出了byte的表示范围，会被看做-128。 十六进制二进制写起来太长，为了简化写法，可以将四个二进制位简化为一个0到15的数，10到15用字符A到F表示，这种表示方法称为16进制，如下所示： 二进制 十进制 十六进制 1010 10 A 1011 11 B 1100 12 C 1101 13 D 1110 14 E 1111 15 F 可以用16进制直接写常量数字，在数字前面加0x即可。比如10进制的123，用16进制表示是0x7B，即123 = 7*16+11。给整数赋值或者进行运算的时候，都可以直接使用16进制，比如： 1int a = 0x7B; Java中不支持直接写二进制常量，比如，想写二进制形式的11001，Java中不能直接写，可以在前面补0，补足8位，为00011001，然后用16进制表示，即 0x19。 位运算位运算是将数据看做二进制，进行位级别的操作，Java不能单独表示一个位，但是可以用byte表示8位，可以用16进制写二进制常量。比如： 0010表示成16进制是 0x2, 110110表示成16进制是 0x36。 位运算有移位运算和逻辑运算。 移位有： 左移：操作符为&lt;&lt;，向左移动，右边的低位补0，高位的就舍弃掉了，将二进制看做整数，左移1位就相当于乘以2。 无符号右移：操作符为&gt;&gt;&gt;，向右移动，右边的舍弃掉，左边补0。 有符号右移：操作符为&gt;&gt;，向右移动，右边的舍弃掉，左边补什么取决于原来最高位是什么，原来是1就补1，原来是0就补0，将二进制看做整数，右移1位相当于除以2。 例如： 123int a = 4; // 100a = a &gt;&gt; 2; // 001，等于1a = a &lt;&lt; 3 // 1000，变为8 逻辑运算有： 按位与 &amp;：两位都为1才为1 按位或 |：只要有一位为1，就为1 按位取反 ~： 1变为0，0变为1 按位异或 ^ ：相异为真，相同为假 大部分都比较简单，就不详细说了。具体形式，例如： 123int a = ...;a = a &amp; 0x1 // 返回0或1，就是a最右边一位的值。a = a | 0x1 //不管a原来最右边一位是什么，都将设为1 小结本节我们讨论了整数的二进制表示，需要注意的就是负数的二进制表示，以及计算机进行二进制加减操作的过程，从而我们就能理解为什么有的时候正整数计算会出现负数。 理解了整数，那小数呢？请见下节分享。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"基本运算","slug":"基本运算","date":"2018-04-05T14:09:37.000Z","updated":"2020-03-31T16:15:04.330Z","comments":true,"path":"2018/04/05/基本运算/","link":"","permalink":"http://example.com/2018/04/05/%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97/","excerpt":"","text":"运算计算机之所以称为”计算”机，是因为发明它的主要目的就是运算。运算有不同的类型，不同的数据类型支持的运算也不一样，本文介绍Java中基本类型数据的主要运算。 算术运算：主要是日常的加减乘除 比较运算：主要是日常的大小比较 逻辑运算：针对布尔值进行运算 算术运算算术运算符有加减乘除，符号分别是+-*/，另外还有取模运算符%，以及自增(++)和自减(–)运算符。取模运算适用于整数和字符类型，其他算术运算适用于所有数值类型和字符类型，其他都符合常识，但字符类型看上去比较奇怪，后续文章解释。 减号(-)通常用于两个数相减， 但也可以放在一个数前面，例如 -a, 这表示改变a的符号，原来的正数会变为负数，原来的负数会变为正数，这也是符合我们常识的。 取模(%)就是数学中的求余数，例如，5%3是2，10%5是0。 自增(++)和自减(–)，是一种快捷方式，是对自己进行加一或减一操作。 加减乘除大部分情况和直观感觉是一样的，都很容易理解，但有一些需要注意的地方，而自增自减稍微复杂一些，下面我们解释下。 加减乘除注意事项 运算时要注意结果的范围，使用恰当的数据类型。两个正数都可以用int表示，但相乘的结果可能就会超，超出后结果会令人困惑，例如： 1int a = 2147483647*2; //2147483647是int能表示的最大值 a的结果是-2。为什么是-2我们暂不解释，要避免这种情况，我们的结果类型应使用long，但只改为long也是不够的，因为运算还是默认按照int类型进行，需要将至少一个数据表示为long形式，即在后面加L或l，下面这样才会出现期望的结果： 1long a = 2147483647*2L; 另外，需要注意的是，整数相除不是四舍五入，而是直接舍去小数位，例如： 1double d = 10/4; 结果是2而不是2.5，如果要按小数进行运算，需要将至少一个数表示为小数形式，或者使用强制类型转化，即在数字前面加(double)，表示将数字看做double类型，如下所示任意一种形式都可以： 12double d = 10/4.0;double d = 10/(double)4; 小数计算结果不精确 无论是使用float还是double，进行运算时都会出现一些非常令人困惑的现象，比如： 12float f = 0.1f*0.1f;System.out.println(f); 这个结果看上去，不言而喻，应该是0.01，但实际上，屏幕输出却是0.010000001，后面多了个1。换用double看看： 12double d = 0.1*0.1;System.out.println(d); 屏幕输出0.010000000000000002，一连串的0之后多了个2，结果也不精确。 这是怎么回事？看上去这么简单的运算，计算机怎么能计算不精确呢？但事实就是这样，究其原因，我们需要理解float和double的二进制表示，后续文章进行分析。 自增(++)/自减(–) 自增/自减是对自己做加一和减一操作，但每个都有两种形式，一种是放在变量后，例如a++, a–，另一种是放在变量前，例如++a, –a。 如果只是对自己操作，这两种形式也没什么差别，区别在于还有其他操作的时候。放在变量后(a++)，是先用原来的值进行其他操作，然后再对自己做修改，而放在变量前(++a)，是先对自己做修改，再用修改后的值进行其他操作。例如，快捷运算和其等同的运算分别是： 快捷运算 等同运算 b=a++-1 b=a-1 a=a+1 c = ++a-1 a=a+1 c=a-1 arrA[i++]=arrB[++j] j=j+1 arrA[i]=arrB[j] i=i+1 自增/自减是”快捷”操作，是让程序员少写代码的，但遗憾的是，由于比较奇怪的语法和诡异的行为，带给了初学者一些困惑。 比较运算比较运算就是计算两个值之间的关系，结果是一个布尔类型(boolean)的值。比较运算适用于所有数值类型和字符类型。数值类型容易理解，但字符怎么比呢？后续文章解释。 比较操作符有：大于(&gt;)，大于等于(&gt;=)，小于(&lt;)，小于等于(&lt;=)，等于(==)，不等于(!=)。 大部分也都是比较直观的，需要注意的是等于。 首先，它使用两个等号==，而不是一个等号(=)，为什么不用一个等号呢？因为一个等号(=)已经被占了，表示赋值操作。 另外，对于数组，==判断的是两个数组是不是同一个数组，而不是两个数组的元素内容是否一样，即使两个数组的内容是一样的，但如果是两个不同的数组，==依然会返回false，如下所示： 123int[] a = new int[] &#123;1,2,3&#125;;int[] b = new int[] &#123;1,2,3&#125;;// a==b的结果是false 如果需要比较数组的内容是否一样，需要逐个比较里面存储的每个元素。 逻辑运算逻辑运算根据数据的逻辑关系，生成一个布尔值true或者false。逻辑运算只可应用于boolean类型的数据，但比较运算的结果是布尔值，所以其他类型数据的比较结果可进行逻辑运算。 逻辑运算符具体有： 与(&amp;)：两个都为true才是true，只要有一个是false就是false 或(|)：只要有一个为true就是true，都是false才是false 非(!)：针对一个变量，true会变成false, false会变成true 异或(^)：两个相同为false, 两个不相同为true 短路与(&amp;&amp;): 和&amp;类似，不同之处马上解释 短路或 (||)：与|类似，不同之处马上解释逻辑运算的大部分都是比较直观的，需要注意的是&amp;和&amp;&amp;，以及|和||的区别。如果只是进行逻辑运算，它们也都是相同的，区别在于同时有其他操作的情况下，例如：123boolean a = true;int b = 0;boolean flag = a | b++&gt;0; 因为a为true，所以flag也为true，但b的结果为1，因为|后面的式子也会进行运算，即使只看a已经知道flag的结果，还是会进行后面的运算。而||则不同，如果最后一句的代码是：1boolean flag = a || b++&gt;0; 则b的值还是0，因为||会”短路”，即在看到||前面部分就可以判定结果的情况下，忽略||后面的运算。 这个例子我们还可以看出，自增/自减操作带给我们的困扰，别的操作都干干脆脆，赋值就赋值，加法就加法，比较就比较，它非混在一起，可能会少写些代码，但如果使用不当，会使理解困难很多。 运算符优先级一个稍微复杂的运算可能会涉及多个变量，和多种运算，那哪个先算，哪个后算呢？程序语言规定了不同运算符的优先级，有的会先算，有的会后算，大部分情况下，这个优先级与我们的常识理解是相符的。 但在一些复杂情况下，我们可能会搞不明白其运算顺序。但这个我们不用太操心，可以使用括号()来表达我们想要的顺序，括号里的会先进行运算，简单的说，不确定顺序的时候，就使用括号。 小结本节我们介绍了算术运算，比较运算和逻辑运算，但我们遗留了一些问题，比如： 正整数相乘的结果居然出现了负数 非常基本的小数运算结果居然不精确 字符类型怎么也可以进行算术运算和比较 这是怎么回事呢? 请见下节分享。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"变量赋值","slug":"变量赋值","date":"2018-04-01T14:09:37.000Z","updated":"2020-03-31T15:50:05.496Z","comments":true,"path":"2018/04/01/变量赋值/","link":"","permalink":"http://example.com/2018/04/01/%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC/","excerpt":"","text":"赋值通过声明变量，每个变量赋予一个数据类型和一个有意义的名字，我们就告诉了计算机我们要操作的数据。有了数据，我们能做很多操作。但本文只说说对数据做的第一个操作：赋值 声明变量之后，就在内存分配了一块位置，但这个位置的内容是未知的，赋值就是把这块位置的内容设为一个确定的值。 Java中基本类型、数组、对象的赋值有明显不同。这里先介绍基本类型和数组的赋值，关于对象后续文章会详述。 基本类型的赋值整数类型整数类型有byte, short, int和long，分别占用1/2/4/8个字节，取值范围分别是： 类型名 取值范围 byte -2^7 ~ 2^7-1 short -2^15 ~ 2^15-1 int -2^31 ~ 2^31-1 long -2^63 ~ 2^63-1 我们用^表示指数，2^7即2的7次方。这个范围我们不需要记的那么清楚，有个大概范围认识就可以了，大多数日常应用，一般用int就可以了。后续文章会从二进制的角度进一步分析表示范围为什么会是这样的。 赋值形式很简单，直接把熟悉的数字常量形式赋值给变量即可，对应的内存空间的值就从未知变成了确定的常量。但常量不能超过对应类型的表示范围。例如： 1234byte b = 23;short s = 3333;int i = 9999;long l = 32323; 但是，在给long类型赋值时，如果常量超过了int的表示范围，需要在常量后面加大写或小写的L，即L或l，例如: 1long a = 3232343433L; 这个是由于数字常量默认为是int类型。 小数类型 小数类型有float和double，占用的内存空间分别是4和8个字节，有不同的取值范围和精度，double表示的范围更大，精度更高，具体来说： 类型名 取值范围 float 1.4E-45 ~ 3.4E+38 -3.4E+38 ~-1.4E-45 double 4.9E-324 ~1.7E+308 -1.7E+308 ~ -4.9E-324 取值范围看上去很奇怪，一般我们也不需要记住，有个大概印象就可以了。E表示以10为底的指数，E后面的+号和-号代表正指数和负指数，例如：1.4E-45表示1.4乘以10的-45次方。 对于double，直接把熟悉的小数表示赋值给变量即可，例如： 1double d = 333.33; 但对于float，需要在数字后面加大写F或小写f，例如： 1float f = 333.33f; 这个是由于小数常量默认为是double类型。 除了小数，也可以把整数直接赋值给float或double，例如： 12float f = 33;double d = 3333333333333L; boolean类型 这个很简单，直接使用true或false赋值，分别表示真和假，例如： 12boolean b = true;b = false; 字符类型 字符类型char用于表示一个字符，这个字符可以是中文字符，也可以是英文字符。在内存中，Java用两个字节表示一个字符。赋值时把常量字符用单引号括起来，不要使用双引号，例如：java 12char c = &#x27;A&#x27;;char z = &#x27;中&#x27;; 上面介绍的赋值都是在声明变量的时候就进行了赋值，但这不是必须的，可以先声明变量，随后再进行赋值。 数组类型赋值语法 基本类型的数组有三种赋值形式，如下所示： 12341. int[] arr = &#123;1,2,3&#125;;2. int[] arr = new int[]&#123;1,2,3&#125;;3. int[] arr = new int[3]; arr[0]=1; arr[1]=2; arr[2]=3; 第一种和第二种都是预先知道数组的内容，而第三种是先分配长度，然后再给每个元素赋值。 第三种形式中，即使没有给每个元素赋值，每个元素也都有一个默认值，这个默认值跟数组类型有关。数值类型的值为0，boolean为false, char为空字符。 数组长度可以动态确定，如下所示： 12int length = ... ;//根据一些条件动态计算int arr = new int[length]; 虽然可以动态确定，但定了之后就不可以变，数组有一个length属性，但只能读，不能改。 一个小细节，不能在给定初始值的同时还给定长度，即如下格式是不允许的： 1int[] arr = new int[3]&#123;1,2,3&#125; 数组和基本类型的区别 一个基本类型变量，内存中只会有一块对应的内存空间。但数组有两块，一块用于存储数组内容本身，另一块用于存储内容的位置。 用一个例子来说明，有一个int变量a，和一个int数组变量arr，其代码，变量对应的内存地址和内存内容如下所示： 代码 内存地址 内存数据 int a = 100; 1000 100 int[] arr = {1,2,3}; 2000 3000 3000 1 3004 2 3008 3 基本类型a的内存地址是1000，这个位置存储的就是它的值100。数组类型arr的内存地址是2000，这个位置存储的值是一个位置3000，3000开始的位置存储的才是实际的数据1,2,3。 为什么数组要用两块空间 不能只用一块空间吗？我们来看下面这个代码： 123int[] arrA = &#123;1,2,3&#125;;int[] arrB = &#123;4,5,6,7&#125;;arrA = arrB; 这个代码中，arrA初始的长度是3，arrB的长度是4，后来将arrB的值赋给了arrA。如果arrA对应的内存空间是直接存储的数组内容，那么它将没有足够的空间去容纳arrB的所有元素。 用两块空间存储，这个就简单的多，arrA存储的值就变成了和arrB的一样，存储的都是数组内容{4,5,6,7}的地址，此后访问arrA就和arrB是一样的了，而arrA {1,2,3}的内存空间由于无人引用会被垃圾回收，如下所示 1234567arrA &#123;1,2,3&#125; \\ \\arrB -&gt; &#123;4,5,6,7&#125; 由上，也可以看出，给数组变量赋值和给数组中元素赋值是两回事。给数组中元素赋值是改变数组内容，而给数组变量赋值则会让变量指向一个不同的位置。 上面我们说数组的长度是不可以变的，不可变指的是数组的内容空间，一经分配，长度就不能再变了，但是可以改变数组变量的值，让它指向一个长度不同的空间，就像上例中arrA后来指向了arrB一样。 小结给变量赋值就是将变量对应的内存空间设置为一个明确的值，有了值之后，变量可以被加载到CPU，CPU可以对这些值进行各种运算，运算后的结果又可以被赋值给变量，保存到内存中。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"数据与变量","slug":"数据与变量","date":"2018-03-31T14:09:37.000Z","updated":"2020-03-31T15:52:53.429Z","comments":true,"path":"2018/03/31/数据与变量/","link":"","permalink":"http://example.com/2018/03/31/%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%8F%98%E9%87%8F/","excerpt":"","text":"程序大概是怎么回事计算机就是个机器，这个机器主要由CPU、内存、硬盘和输入输出设备组成。计算机上跑着操作系统，如Windows或Linux，操作系统上运行着各种应用程序，如Word, QQ等。操作系统将时间分成很多细小的时间片，一个时间片给一个程序用，另一个时间片给另一个程序用，并频繁地在程序间切换。不过，在应用程序看来，整个机器资源好像都归他使，操作系统给他提供了这种假象。 对程序员而言，我们写程序，基本不用考虑其他应用程序，我们想好怎么做自己的事就可以了。应用程序看上去能做很多事情，能读写文档，能播放音乐，能聊天，能玩游戏，能下围棋 …… 但本质上，计算机只会执行预先写好的指令而已，这些指令也只是操作数据或者设备。所谓程序，基本上就是告诉计算机要操作的数据和执行的指令序列， 即对什么数据做什么操作。 数据数据是什么？数据在计算机内部都是二进制，不方便操作，为了方便操作数据，高级语言引入了”数据类型”和”变量”的概念。 数据类型数据类型用于对数据归类，方便理解和操作，对Java语言而言，有如下基本数据类型： 整数类型：有四种整型 byte/short/int/long，分别有不同的取值范围 小数类型 ：有两种类型 float/double，有不同的取值范围和精度 字符类型：char，表示单个字符 真假类型：boolean，表示真假 基本数据类型都有对应的数组类型，数组表示固定长度的同种数据类型的多条记录，这些数据在内存中挨在一起存放。 比如说，一个自然数可以用一个整数类型数据表示，100个连续的自然数可以用一个长度为100的整数数组表示。一个字符用一个char表示，一段文字可以用一个char数组表示。Java是一个面向对象的语言，除了基本数据类型，其他都是对象类型 ，对象到底是什么呢？简单的说，对象是由基本数据类型、数组和其他对象组合而成的一个东西，以方便对其整体进行操作。 比如说，一个学生对象，可以由如下信息组成： 姓名：一个字符数组 年龄：一个整数 性别：一个字符 入学分数：一个小数 日期在Java中也是一个对象，内部表示为整形long。就像世界万物的组成，都是由元素周期表中的108个基本元素组成的，基本数据类型就相当于化学中的基本元素，而对象就相当于世界万物。 变量为了操作数据，需要把数据存放到内存中，所谓内存在程序看来就是一块有地址编号的连续的空间，放到内存中的某个位置后，为了方便地找到和操作这个数据，需要给这个位置起一个名字。编程语言通过变量这个概念来表示这个过程。 声明一个变量，比如 int a其实就是在内存中分配了一个空间，这个空间存放int数据类型，a指向这个内存空间所在的位置，通过对a操作即可操作a指向的内存空间，比如a=5这个操作即可将a指向的内存空间的值改为5。 之所以叫变量，是因为它表示的是内存中的位置，这个位置存放的值是可以变化的。 虽然变量的值是可以变化的，但名字是不变的，这个名字应该代表程序员心目中这块内存位置的意义，这个意义应该是不变的，比如说这个变量int second表示时钟秒数，在不同时间可以被赋予不同的值，但它表示的就是时钟秒数。之所以说应该是因为这不是必须的，如果你非要起一个变量名叫age但赋予它身高的值，计算机也拿你没办法。 重要的话再说一遍！变量就是给数据起名字，方便找不同的数据，它的值可以变，但含义不应变。再比如说一个合同，可以有四个变量： first_party: 含义是甲方 second_party: 含义是乙方 contract_body: 含义是合同内容 contract_sign_date: 含义是合同签署日期 这些变量表示的含义是确定的，但对不同的合同，他们的值是不同的。 初学编程的人经常使用像a,b,c,hehe,haha这种无意义的名字，给变量起一个有意义的名字吧!","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Windows批处理常用命令","slug":"Windows批处理常用命令","date":"2017-03-10T10:00:42.000Z","updated":"2021-04-24T12:06:46.629Z","comments":true,"path":"2017/03/10/Windows批处理常用命令/","link":"","permalink":"http://example.com/2017/03/10/Windows%E6%89%B9%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"批处理文件（batch file）包含一系列 DOS命令，通常用于自动执行重复性任务。用户只需双击批处理文件便可执行任务，而无需重复输入相同指令。编写批处理文件非常简单，但难点在于确保一切按顺序执行。编写严谨的批处理文件可以极大程度地节省时间，在应对重复性工作时尤其有效 在Windows中善用批处理可以简化很多重复工作 ## 什么是批处理？ 批处理(Batch)，也称为批处理脚本。顾名思义，批处理就是对某对象进行批量的处理。批处理文件的扩展名为bat。 批处理是一种简化的脚本语言，它应用于DOS和Windows系统中，它是由DOS或者Windows系统内嵌的命令解释器（通常是COMMAND.COM或者CMD.EXE）解释运行。 批处理类似于Unix中的Shell脚本。批处理文件具有.bat或者.cmd的扩展名，其最简单的例子，是逐行书写在命令行中会用到的各种命令。更复杂的情况，需要使用if，for，goto等命令控制程序的运行过程，如同C，Basic等中高级语言一样。如果需要实现更复杂的应用，利用外部程序是必要的，这包括系统本身提供的外部命令和第三方提供的工具或者软件。 怎么创建批处理文件？ 批处理文件，或称为批处理程序，是由一条条的DOS命令组成的普通文本文件，可以用记事本直接编辑或用DOS命令创建，也可以用DOS下的文本编辑器Edit.exe来编辑。在命令提示下键入批处理文件的名称，或者双击该批处理文件，系统就会调用Cmd.exe运行该批处理程序。 一般情况下，每条命令占据一行，当然也可以将多条命令用特定符号（如：&amp;、&amp;&amp;、|、||等）分隔后写入同一行中。 还有的情况就是像if、for等较高级的命令则要占据几行甚至几十几百行的空间。系统在解释运行批处理程序时，首先扫描整个批处理程序，然后从第一行代码开始向下逐句执行所有的命令，直至程序结尾或遇见exit命令或出错意外退出。 批处理常用命令介绍echo和@命令echo表示打开回显或关闭请求回显功能，或显示消息。如果没有任何参数，echo 命令将显示当前回显设置。 @表示不显示@后面的命令 。 12345678910::从下一行开始关闭回显 echo off ::从本行开始关闭回显。一般批处理第一行都是这个 @echo off ::从下一行开始打开回显echo on ::显示当前是 echo off 状态还是 echo on 状态 echo ::输出一个”回车换行”，空白行echo. Rem和 :: 命令注释命令，相当于C语言中的/——–/，它不会被显示和执行，只是起一个注释的作用，便于别人阅读和你自己日后修改。 123456@echo offecho hello world1Rem this is a comment.:: this is a comment.echo hello world2pause Pause 命令会暂停批处理的执行并在屏幕上显示Press any key to continue…的提示，等待用户按任意键后继续 。 123@echo offecho hello worldpause Call命令调用另一个批处理程序，并且不终止父批处理程序。 如果不用call而直接调用别的批处理文件，那么执行完那个批处理文件后将无法返回当前文件并执行当前文件的后续命令。 如果在脚本或批处理文件外使用 Call，它将不会在命令行起作用。 1call test2.bat arg1 arg2 (调用同目录下的 test2.bat，且输入2个参数给他) Start命令调用外部程序，所有的 DOS命令 和 命令行程序 都可以由 start命令 来调用。 start [“title”] [/dPath] [/i] [/min] [/max] [{/separate | /shared}] [{/low | /normal | /high | /realtime | /abovenormal | belownormal}] [/wait] [/b] [FileName] [parameters] “title” 指定在“命令提示符”窗口标题栏中显示的标题。/dpatch 指定启动目录。/i 将 Cmd.exe 启动环境传送到新的“命令提示符”窗口。/min 启动新的最小化窗口。/max 启动新的最大化窗口。/separate 在单独的内存空间启动 16 位程序。/shared 在共享的内存空间启动 16 位程序。/low 以空闲优先级启动应用程序。/normal 以一般优先级启动应用程序。/high 以高优先级启动应用程序。/realtime 以实时优先级启动应用程序。/abovenormal 以超出常规优先级的方式启动应用程序。/belownormal 以低出常规优先级的方式启动应用程序。/wait 启动应用程序，并等待其结束。/b 启动应用程序时不必打开新的“命令提示符”窗口。除非应用程序启用 CTRL+C，否则将忽略 CTRL+C 操作。使用 CTRL+BREAK 中断应用程序。 如果你所在程序的路径中带有空格，那么必须用“”把路径括起来，否则系统会提示找不到XX文件，另外，在运行某些程序时，需在路径的前面加一对空白的“”，表示创建一个空白的窗口，它指向的程序是XXXXXXXX。还有就是别忘了空格。 1234start /MIN test2.bat arg1 arg2 (调用同目录下的 test2.bat，且输入2个参数给他，且本窗口最小化)e:\\program files\\xxx.exestart &quot;&quot; &quot;D:/draw/photoshop.exe&quot; 表示以常规窗口运行程序start /min &quot;&quot; &quot;D:/draw/photoshop.exe&quot; 表示以最小化窗口运行程序 等待某个程序允许完毕，也就是窗口关闭后，再打开下一个程序这可以这样： 12start /w &quot;&quot; &quot;D:/draw/photoshop.exe&quot;start &quot;&quot; cmd.exe Set命令显示、设置或删除变量。 显示变量：set 或 set s 前者显示批处理当前已定义的所有变量及其值，后者显示所有以s开头的变量及值。 设置和调用变量：例如set aa=abcd，就是把aa定义为abcd。如果要调用这个变量，就把aa两边加上个百分号。 例如： 123set aa=abcdecho %aa%pause 运行这段命令就会显示“abcd”。 删除变量：set aa= 此句命令即可删除变量aa。若变量aa已被定义，则删除变量aa；若aa尚未定义，则此句命令无实质意义。 需要说明的是，批处理中的变量是不区分类型的，不需要像C语言中的变量那样还要区分int、float、char等。比如执行set aa=345后，变量aa的值既可以被视为数字345，也可以被视为字符串345。 set命令具有扩展功能，如用作交互输入、字符串处理、数值计算等，属于高级命令范畴。 If 命令if 表示将判断是否符合规定的条件，从而决定执行不同的命令。有三种格式: if [not] string1 compare-op string2 command1 [else command2]if [not] “参数” == “字符串” 待执行的命令参数如果等于(not表示不等，下同)指定的字符串，则条件成立，运行命令，否则运行下一句。(注意是两个等号) 比较操作符compare-op有以下几类： == - 等于 EQU - 等于 NEQ - 不等于 LSS - 小于 LEQ - 小于或等于 GTR - 大于 GEQ - 大于或等于 12if &quot;%1&quot; == &quot;a&quot; format a:if &#123;%1&#125; == &#123;&#125; goto noparms if exist语法: if [not] exist [路径]文件名 待执行的命令如果有指定的文件，则条件成立，运行命令，否则运行下一句。Sample: if exist config.sys edit config.sys (表示如果存在这文件，则编辑它，用很难看的系统编辑器)Sample: if exist config.sys type config.sys (表示如果存在这文件，则显示它的内容) if errorlevel number语法: if [not] errorlevel &lt;数字&gt; 待执行的命令如果程序返回值等于指定的数字，则条件成立，运行命令，否则运行下一句。(返回值必须按照从大到小的顺序排列) 12345@echo offXCOPY F:\\test.bat D:\\IF ERRORLEVEL 1 (ECHO 文件拷贝失败) Else IF ERRORLEVEL 0 ECHO 成功拷贝文件pause Goto 命令指定跳转到标签，找到标签后，程序将处理从下一行开始的命令。 语法：goto label （label是参数，指定所要转向的批处理程序中的行。） 123456if &#123;%1&#125;==&#123;&#125; goto noparmsif &#123;%2&#125;==&#123;&#125; goto noparms（如果这里的if、%1、%2你不明白的话，先跳过去，后面会有详细的解释。）@Rem check parameters if null show usage:noparmsecho Usage: monitor.bat ServerIP PortNumbergoto end 标签的名字可以随便起，但是最好是有意义的字母啦，字母前加个：用来表示这个字母是标签，goto命令就是根据这个：来寻找下一步跳到到那里。最好有一些说明这样你别人看起来才会理解你的意图啊。 choice 命令choice 使用此命令可以让用户输入一个字符(用于选择)，从而根据用户的选择返回不同的 errorlevel，然后配合 if errorlevel 选择运行不同的命令。注意：choice命令为DOS或者Windows系统提供的外部命令，不同版本的choice命令语法会稍有不同，请用choice /?查看用法。choice 使用此命令可以让用户输入一个字符，从而运行不同的命令。使用时应该加/c:参数，c:后应写提示可输入的字符，之间无空格。它的返回码为1234…… Sample: choice /c:dme defrag,mem,end将显示: defrag,mem,end[D,M,E]? 1234choice /c:dme defrag,mem,endif errorlevel 3 goto defrag (应先判断数值最高的错误码)if errorlevel 2 goto memif errotlevel 1 goto end for命令for 命令是一个比较复杂的命令，主要用于参数在指定的范围内循环执行命令。 for 命令，一般格式如下： 在cmd窗口中使用格式： 1FOR %variable IN (set) DO command [command-parameters] 在批处理脚本中使用格式： 1FOR %%variable IN (set) DO command [command-parameters] 在cmd窗口中使用，变量名必须用单%引用（即：%variable）；在批处理脚本中使用，变量名必须用双%引用（即：%%variable）。 for、in和do是for命令的三个关键字，缺一不可。 关键字in之后，do之前的括号不能省略。 123@echo offfor %%i in (1 2 3 4 5) do @echo %%ipause&gt;nul errorlevel程序返回码echo %errorlevel%每个命令运行结束，可以用这个命令行格式查看返回码用于判断刚才的命令是否执行成功默认值为0，一般命令执行出错会设 errorlevel 为1 title设置cmd窗口的标题title 新标题 #可以看到cmd窗口的标题栏变了 COLOR设置默认的控制台前景和背景颜色。COLOR [attr]attr 指定控制台输出的颜色属性颜色属性由两个十六进制数字指定 – 第一个为背景，第二个则为前景。每个数字可以为以下任何值之一:0 = 黑色 8 = 灰色1 = 蓝色 9 = 淡蓝色2 = 绿色 A = 淡绿色3 = 湖蓝色 B = 淡浅绿色4 = 红色 C = 淡红色5 = 紫色 D = 淡紫色6 = 黄色 E = 淡黄色7 = 白色 F = 亮白色如果没有给定任何参数，该命令会将颜色还原到 CMD.EXE 启动时的颜色。这个值来自当前控制台窗口、/T 开关或DefaultColor 注册表值。如果用相同的前景和背景颜色来执行 COLOR 命令，COLOR 命令会将 ERRORLEVEL 设置为 1。例如: “COLOR fc” 在亮白色上产生亮红色 FIND在文件中搜索字符串。FIND [/V] [/C] [/N] [/I] [/OFF[LINE]] “string” [[drive:][path]filename[ …]] /V 显示所有未包含指定字符串的行。/C 仅显示包含字符串的行数。/N 显示行号。/I 搜索字符串时忽略大小写。/OFF[LINE] 不要跳过具有脱机属性集的文件。“string” 指定要搜索的文字串，[drive:][path]filename 指定要搜索的文件。 基本格式：find “要查找的字符串” 要查找的文件(不在当前目录则需要给出完整路径) 1find &quot;abc&quot; d:\\abc.txt 在abc.txt中查找字符串abc的行。 常见问题中文乱码解决批处理显示中文乱码问题，可在批处理文件中加入如下命令： 1chcp 65001 获取路径12345678@echo offecho 当前路径：%cd%echo 当前盘符：%~d0 echo 当前盘符和路径：%~dp0 echo 当前批处理全路径：%~f0 echo 当前盘符和路径的短文件名格式：%~sdp0 echo 当前CMD默认目录：%cd% pause 等待固定时间再执行主要有两种方法：第一种（等待时间不精确） 1234@echo off命令1.......ping -n 5 127.1&gt;nul命令2....... 第二种（时间较精确） 1234@echo off命令1.......echo wscript.sleep 5000&gt;%tmp%delay.vbs&amp;&amp;%tmp%delay.vbs&amp;&amp;del /q %tmp%delay.vbs命令2.......","categories":[{"name":"Windows批处理","slug":"Windows批处理","permalink":"http://example.com/categories/Windows%E6%89%B9%E5%A4%84%E7%90%86/"}],"tags":[{"name":"批处理","slug":"批处理","permalink":"http://example.com/tags/%E6%89%B9%E5%A4%84%E7%90%86/"}]},{"title":"如何将Hexo托管到GitHub","slug":"如何将Hexo托管到GitHub","date":"2016-07-26T14:20:47.000Z","updated":"2020-03-31T16:33:01.546Z","comments":true,"path":"2016/07/26/如何将Hexo托管到GitHub/","link":"","permalink":"http://example.com/2016/07/26/%E5%A6%82%E4%BD%95%E5%B0%86Hexo%E6%89%98%E7%AE%A1%E5%88%B0GitHub/","excerpt":"","text":"如何将Hexo托管到GitHub托管步骤步骤1：首先，你要先有一个GitHub账户，没有就去注册一个吧。注册完登录后，会在GitHub.com中看到一个New repository（新建仓库）。 步骤2：创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxx.github.io，其中xxx就是你注册GitHub的用户名。 步骤3：生成SSH添加到GitHub，在Git bash中输入如下命令： 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱，这样GitHub才能知道你是不是它的账户。可以用以下两条命令检查你现在的用户名和邮箱： 12git config user.namegit config user.email 然后创建SSH，输入如下命令： 1ssh-keygen -t rsa -C &quot;youremail&quot; 之后一路回车就行。SSH简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。步骤4：在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key把你的id_rsa.pub里面的信息复制进去，通过如下命令查看是否设置成功： 1ssh -T git@github.com 完成这一步，我们就将hexo和GitHub关联起来了。步骤5：打开我们之前介绍的站点配置文件_config.yml，找到如下内容： 1234deploy: type: git repo: git@github.com:[yourname]&#x2F;[yourname].github.io.git branch: master 修改[yourname]为你的GitHub账户，然后输入安装deploy-git的命令 ： 1npm install hexo-deployer-git --save 这样你才能用命令部署到GitHub。步骤6：最后输入如下命令： 123hexo cleanhexo generatehexo deploy hexo clean 清除你之前生成的东西，也可以不加。hexo generate (可缩写hexo g) 顾名思义，生成静态文章hexo deploy (可缩写hexo d) 部署文章 设置个人域名现在你的个人博客网站的地址默认是yourname.github.io，如果你觉得这个网址逼格太low了，则可以设置自己的个人域名。步骤1：如果你没有自己的域名，你就需要花钱去注册或买一个自己域名，一般在域名购买网站的域名管理后台中你可以看到你购买的域名。你可以添加解析，将GitHub的服务器地址设置进去192.30.252.153 和 192.30.252.154 是GitHub的服务器地址。 解析线路一般选择默认，但你也可以用这个来做国内外分流。 步骤2：登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名。然后在你的博客文件source中创建一个名为CNAME文件，不要后缀，写上你的域名。 步骤3：最后重新部署一下即可： 123hexo cleanhexo ghexo d","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]},{"title":"Hexo博客开源框架的使用","slug":"Hexo博客开源框架的使用","date":"2016-07-02T11:30:14.000Z","updated":"2021-04-01T06:23:18.701Z","comments":true,"path":"2016/07/02/Hexo博客开源框架的使用/","link":"","permalink":"http://example.com/2016/07/02/Hexo%E5%8D%9A%E5%AE%A2%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Hexo介绍Hexo是一款基于Node.js的开源博客框架。你可以用MarkDown（或者其他标记语言）来书写自己的博客，然后通过Hexo快速生成静态的博客站点，还可将其托管到GitHub上，使用起来十分方便。当然，Hexo也允许你应用许多漂亮的主题来装饰自己的站点，你可以通过Hexo主题市场来获取你感兴趣的主题。 Hexo博客站点搭建环境准备需要先安装配置以下两个环境，如已安装请忽略此步 Git Node.js这里建议均安装最新版本，因为Hexo是在不断更新的，需要依赖最新的环境。 安装完后注意检查环境变量的配置，在CMD中通过以下命令来检查是否配置成功： 12node -v npm -v 1git --version ### 安装Hexo 当以上环境都安装好后，就可以利用[npm](https://www.npmjs.com/)来安装Hexo了。新建一个文件夹，进入该文件夹然后右键Git Bash Here，在命令窗口输入以下命令安装Hexo： 1npm install -g hexo-cli 接着输入初始化Hexo命令，该命令会在该文件夹下新生成一个blog文件夹，放置Hexo主要的工作文件： 1hexo init blog 进入blog文件夹，安装Hexo依赖的插件： 12cd blognpm install 此时该文件夹的目录结构变为： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 启动Hexo站点： 1hexo server 在[http://localhost:4000/](http://localhost:4000/)中查看Hexo生成的默认站点，Hexo安装就大功告成了。 ### 配置Hexo 这里介绍一些比较重要的配置 打开blog文件夹下的_config.yml文件，可对Hexo站点进行一些基本的配置 title:站点显示名称description:站点描述author:作者post_asset_folder:站点部署的时候允许上传资源文件夹（如果要上传图片则设为true）theme:设置主题的名称deploy:远程部署站点的相关设置 Hexo基本操作初始化站点 1hexo init [folder] folder为你指定的文件夹名称，没有则自动创建新建文章 1hexo new [layout] &lt;title&gt; 如果没有指定layout，则会使用_config.yml中定义的默认layout；title为生成的.md文件兼文章的标题，文章标题也可到具体的文件中去修改，生成的文件位于/source/_posts/目录下 清理缓存和生成的文件 1hexo clean 清理缓存文件（db.json）和生成的文件(public) 生成网站的静态文件 1hexo generate 或 hexo g 启动一个本地站点 1hexo server 或 hexo s 默认地址为http://localhost:4000/，一般用于调试和查看效果部署站点 1hexo deploy 需配合_config.yml中配置的deploy使用，将自己的本地站点文件部署到远程服务器或仓库。","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]}],"categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"},{"name":"Windows批处理","slug":"Windows批处理","permalink":"http://example.com/categories/Windows%E6%89%B9%E5%A4%84%E7%90%86/"},{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"批处理","slug":"批处理","permalink":"http://example.com/tags/%E6%89%B9%E5%A4%84%E7%90%86/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]}