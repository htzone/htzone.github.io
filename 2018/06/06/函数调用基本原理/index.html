<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> 函数调用基本原理 · RedPig's Blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="函数调用基本原理 - RedPig"><meta name="keywords" content="java函数"><meta name="author" content="RedPig"><link rel="short icon" href="/images/favicon.png"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="http://example.com/atom.xml" title="RedPig's Blog"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="RedPig's Blog" type="application/atom+xml">
</head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="目录" class="nav-list-link">目录</a></li><li class="nav-list-item"><a href="https://github.com/htzone" target="_blank" data-hover="项目" class="nav-list-link">项目</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">函数调用基本原理</h1><div class="post-info">2018-06-06</div><div class="post-content"><p>如果需要经常做某一个操作，则类似的代码需要重复写很多遍，比如在一个数组中查找某个数，第一次查找一个数，第二次可能查找另一个数，每查一个数，类似的代码都需要重写一遍，很罗嗦。另外，有一些复杂的操作，可能分为很多个步骤，如果都放在一起，则代码难以理解和维护。 </p>
<p>计算机程序使用函数这个概念来解决这个问题，即使用函数来减少重复代码和分解复杂操作，本文我们就来谈谈Java中的函数，包括函数的基础和调用原理等相关知识。 </p>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p> 函数的基本语法结构，即： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型  函数名字(参数类型 参数名字, ...) &#123;</span><br><span class="line">    操作 ...</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的主要组成部分有：</p>
<ul>
<li>函数名字：名字是不可或缺的，表示函数的功能。</li>
<li>参数：参数有0个到多个，每个参数有参数的数据类型和参数名字组成。</li>
<li>操作：函数的具体操作代码。</li>
<li>返回值：函数可以没有返回值，没有的话返回值类型写成void，有的话在函数代码中必须要使用return语句返回一个值，这个值的类型需要和声明的返回值类型一致。</li>
<li>修饰符：Java中函数有很多修饰符，分别表示不同的目的，在本节我们假定修饰符为public static，且暂不讨论这些修饰符的目的。</li>
</ul>
<p>以上就是定义函数的语法，定义函数就是定义了一段有着明确功能的子程序，但定义函数本身不会执行任何代码，函数要被执行，需要被调用。</p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>Java中，任何函数都需要放在一个类中 ，Java中函数一般叫做方法，我们不特别区分函数和方法，可能会交替使用。一个类里面可以定义多个函数，类里面可以定义一个叫做main的函数，形式如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数有特殊的含义，表示程序的入口，String[] args表示从控制台接收到的参数。Java中运行一个程序的时候，需要指定一个定义了main函数的类，Java会寻找main函数，并从main函数开始执行。</p>
<p>刚开始学编程的人可能会误以为程序从代码的第一行开始执行，这是错误的，不管main函数定义在哪里，Java函数都会先找到它，然后从它的第一行开始执行。main函数中除了可以定义变量，操作数据 ，还可以调用其它函数 。</p>
<p>对于需要重复执行的代码，可以定义函数，然后在需要的地方调用，这样可以减少重复代码。对于复杂的操作，可以将操作分为多个函数，会使得代码更加易读。</p>
<p>程序执行基本上只有顺序执行、条件执行和循环执行，但更完整的描述应该包括函数的调用过程。程序从main函数开始执行，碰到函数调用的时候，会跳转进函数内部，函数调用了其他函数，会接着进入其他函数，函数返回后会继续执行调用后面的语句，返回到main函数并且main函数没有要执行的语句后程序结束。 </p>
<div class="tip"> 在Java中，函数在程序代码中的位置和实际执行的顺序是没有关系的。</div>
函数的定义和基本调用应该是比较容易理解的，但有很多细节可能令初学者困惑，包括参数传递、参数类型，返回、函数命名、调用过程等，我们逐个讨论下。 

<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><h3 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h3><p>形式参数：是在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传入的参数，简称“形参”。</p>
<p>实际参数：在主调函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”，简称“实参”。  </p>
<p>举个栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ParamTest pt = <span class="keyword">new</span> ParamTest();</span><br><span class="line">        <span class="comment">// 实际参数为“张三”</span></span><br><span class="line">        pt.sout(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sout</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 形式参数为 name</span></span><br><span class="line">        System.out.print(name);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h3><p>值传递：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p>
<p>引用传递：指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
<p>两者的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th align="center">值传递</th>
<th>引用传递</th>
</tr>
</thead>
<tbody><tr>
<td>根本区别</td>
<td align="center">会创建副本</td>
<td>不会创建副本</td>
</tr>
<tr>
<td>所以</td>
<td align="center">函数中无法改变原始对象</td>
<td>函数中可以改变原始对象</td>
</tr>
</tbody></table>
<p>那Java中使用的究竟是值传递还是引用传递呢？我们将在后面给出答案。</p>
<h2 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h2><p>函数主要的参数类别又可分为基本类型参数，引用类型参数，数组参数和可变长度参数，以下我们逐个进行介绍。</p>
<h3 id="基本类型参数"><a href="#基本类型参数" class="headerlink" title="基本类型参数"></a>基本类型参数</h3><p>基本类型参数很好理解，就是简单的值传递，直接将值复制到函数内部进行使用，基本类型不会对调用者中的变量造成任何影响 。</p>
<h3 id="引用类型参数"><a href="#引用类型参数" class="headerlink" title="引用类型参数"></a>引用类型参数</h3><p>那引用类型参数是不是使用的引用传递呢？我们来看下面的栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	User user = <span class="keyword">new</span> User();</span><br><span class="line">	user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	user.setAge(<span class="number">18</span>);</span><br><span class="line">	System.out.println(<span class="string">&quot;call方法调用前，user=&quot;</span> + user.toString());</span><br><span class="line">	call(user);</span><br><span class="line">	System.out.println(<span class="string">&quot;call方法调用后，user=&quot;</span> + user.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">	user.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">	System.out.println(<span class="string">&quot;call方法中,user = &quot;</span> + user.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">				<span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">				<span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">				<span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，定义了一个User类，在main方法中，new了一个新的User对象user，然后给user对象的成员变量赋值，call方法中，修改了传入的user对象的属性。</p>
<p>运行main方法，结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call方法调用前，user= User&#123;name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="number">18</span>&#125;</span><br><span class="line">call方法中,user = User&#123;name=<span class="string">&#x27;李四&#x27;</span>, age=<span class="number">18</span>&#125;</span><br><span class="line">call方法调用后，user= User&#123;name=<span class="string">&#x27;李四&#x27;</span>, age=<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>
<p>引用类型参数与基本类型参数略有不同，但使用的仍然是值传递，只不过对于引用类型参数，值的内容是对象的引用。 就是在调用函数时只将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到调用者中的变量</p>
<div class="tip">在Java中，方法参数的传递不管是基本数据类型还是引用类型都是值传递 </div>

<h3 id="数组参数"><a href="#数组参数" class="headerlink" title="数组参数"></a>数组参数</h3><p>数组与引用参数类似，在函数内修改数组中的元素会修改调用者中的数组内容。我们看个例子： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        arr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;;</span><br><span class="line">    reset(arr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在reset函数内给参数数组元素赋值，在main函数中数组arr的值也会变。</p>
<p>这个其实也容易理解， 一个数组变量有两块空间，一块用于存储数组内容本身，另一块用于存储内容的位置，给数组变量赋值不会影响原有的数组内容本身，而只会让数组变量指向一个不同的数组内容空间，这一点与引用参数类似的。 </p>
<p>在上例中，函数参数中的数组变量arr和main函数中的数组变量arr存储的都是相同的位置，而数组内容本身只有一份数据，所以，在reset中修改数组元素内容和在main中修改是完全一样的。 </p>
<h3 id="可变长度参数"><a href="#可变长度参数" class="headerlink" title="可变长度参数"></a>可变长度参数</h3><p>上面介绍的函数，参数个数都是固定的，但有的时候，可能希望参数个数不是固定的，比如说求若干个数的最大值，可能是两个，也可能是多个，Java支持可变长度的参数，如下例所示： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> ... a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = min;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max&lt;a[i])&#123;</span><br><span class="line">            max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(max(<span class="number">0</span>));</span><br><span class="line">    System.out.println(max(<span class="number">0</span>,<span class="number">2</span>));</span><br><span class="line">    System.out.println(max(<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line">    System.out.println(max(<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个max函数接受一个最小值，以及可变长度的若干参数，返回其中的最大值。可变长度参数的语法是在数据类型后面加三个点…，在函数内，可变长度参数可以看做就是数组，可变长度参数必须是参数列表中的最后一个参数，一个函数也只能有一个可变长度的参数。</p>
<p>可变长度参数实际上会转换为数组参数，也就是说，函数声明max(int min, int… a)实际上会转换为 max(int min, int[] a)，在main函数调用 max(0,2,4,5)的时候，实际上会转换为调用 max(0, new int[]{2,4,5})，使用可变长度参数主要是简化了代码书写。</p>
<h2 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h2><h3 id="return的含义"><a href="#return的含义" class="headerlink" title="return的含义"></a>return的含义</h3><p>对初学者，我们强调下return的含义。 函数返回值类型为void且没有return的情况下，会执行到函数结尾自动返回。return用于结束函数执行，返回调用方。 </p>
<p>return可以用于函数内的任意地方，可以在函数结尾，也可以在中间，可以在if语句内，可以在for循环内，用于提前结束函数执行，返回调用方。</p>
<p>函数返回值类型为void也可以使用return，即return;，不用带值，含义是返回调用方，只是没有返回值而已。</p>
<h3 id="返回值的个数"><a href="#返回值的个数" class="headerlink" title="返回值的个数"></a>返回值的个数</h3><p>函数的返回值最多只能有一个，那如果实际情况需要多个返回值呢？比如说，计算一个整数数组中的最大的前三个数，需要返回三个结果。这个可以用数组作为返回值，在函数内创建一个包含三个元素的数组，然后将前三个结果赋给对应的数组元素。</p>
<p>如果实际情况需要的返回值是一种复合结果呢？比如说，查找一个字符数组中，所有重复出现的字符以及重复出现的次数。这个可以用对象作为返回值。</p>
<h3 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h3><p>每个函数都有一个名字，这个名字表示这个函数的意义，名字可以重复吗？在不同的类里，答案是肯定的，在同一个类里，要看情况。</p>
<p>同一个类里，函数可以重名，但是参数不能一样，一样是指参数个数相同，每个位置的参数类型也一样，但参数的名字不算，返回值类型也不算。换句话说，函数的唯一性标示是：类名<em>函数名_参数1类型_参数2类型</em>…参数n类型。</p>
<p>同一个类中函数名字相同但参数不同的现象，一般称为函数重载。为什么需要函数重载呢？一般是因为函数想表达的意义是一样的，但参数个数或类型不一样。比如说，求两个数的最大值，在Java的Math库中就定义了四个函数，如下所示：</p>
<p><img src="/2018/06/06/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86_p1.png" alt="img"></p>
<h2 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h2><h3 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h3><p>在之前介绍函数调用的时候，我们没有特别说明参数的类型。这里说明一下，参数传递实际上是给参数赋值，调用者传递的数据需要与函数声明的参数类型是匹配的，但不要求完全一样。什么意思呢？Java编译器会自动进行类型转换，并寻找最匹配的函数。比如说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char a &#x3D; &#39;a&#39;;</span><br><span class="line">char b &#x3D; &#39;b&#39;;</span><br><span class="line">System.out.println(Math.max(a,b));</span><br></pre></td></tr></table></figure>

<p>参数是字符类型的，但Math并没有定义针对字符类型的max函数，我们之前说明，char其实是一个整数，Java会自动将char转换为int，然后调用Math.max(int a, int b)，屏幕会输出整数结果98。</p>
<p> 如果Math中没有定义针对int类型的max函数呢？调用也会成功，会调用long类型的max函数，如果long也没有呢？会调用float型的max函数，如果float也没有，会调用double型的。Java编译器会自动寻找最匹配的。<br>在只有一个函数的情况下（即没有重载），只要可以进行类型转换，就会调用该函数，在有函数重载的情况下，会调用最匹配的函数。 </p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>函数大部分情况下都是被别的函数调用，但其实函数也可以调用它自己，调用自己的函数就叫递归函数。</p>
<p>为什么需要自己调用自己呢？我们来看一个例子，求一个数的阶乘，数学中一个数n的阶乘，表示为n!，它的值定义是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0!&#x3D;1</span><br><span class="line">n!&#x3D;(n-1)!×n</span><br></pre></td></tr></table></figure>

<p>0的阶乘是1，n的阶乘的值是n-1的阶乘的值乘以n，这个定义是一个递归的定义，为求n的值，需先求n-1的值，直到0，然后依次往回退。用递归表达的计算用递归函数容易实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n*factorial(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上去应该是比较容易理解的，和数学定义类似。</p>
<p>递归函数形式上往往比较简单，但递归其实是有开销的，而且使用不当，可以会出现意外的结果，比如说这个调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(factorial(10000));</span><br></pre></td></tr></table></figure>

<p>系统并不会给出任何结果，而会抛出异常，异常我们在后续章节介绍，此处理解为系统错误就可以了，异常类型为：java.lang.StackOverflowError，这是什么意思呢？这表示栈溢出错误，要理解这个错误，我们需要理解函数调用的实现原理（下节介绍）。</p>
<p>那如果递归不行怎么办呢？递归函数经常可以转换为非递归的形式，通过一些数据结构（后续章节介绍）以及循环来实现。比如，求阶乘的例子，其非递归形式的定义是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n!&#x3D;1×2×3×…×n</span><br></pre></td></tr></table></figure>

<p>这个可以用循环来实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        result*=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数调用实现机制"><a href="#函数调用实现机制" class="headerlink" title="函数调用实现机制"></a>函数调用实现机制</h2><p>上面我们提到了一个系统异常java.lang.StackOverflowError，栈溢出错误，要理解这个错误，我们需要理解函数调用的实现机制。 </p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>程序从main函数开始顺序执行，函数调用可以看做是一个无条件跳转，跳转到对应函数的指令处开始执行，碰到return语句或者函数结尾的时候，再执行一次无条件跳转，跳转回调用方，执行调用函数后的下一条指令。</p>
<p>但这里面有几个问题：</p>
<ul>
<li>参数如何传递？</li>
<li>函数如何知道返回到什么地方？在if/else, for中，跳转的地址都是确定的，但函数自己并不知道会被谁调用，而且可能会被很多地方调用，它并不能提前知道执行结束后返回哪里。</li>
<li>函数结果如何传给调用方？</li>
</ul>
<p><font color="#0000FF">解决思路是使用内存来存放这些数据，函数调用方和函数自己就如何存放和使用这些数据达成一个一致的协议或约定。这个约定在各种计算机系统中都是类似的，存放这些数据的内存有一个相同的名字，叫栈</font>。</p>
<p>栈是一块内存，但它的使用有特别的约定，一般是先进后出，类似于一个桶，往栈里放数据，我们称为入栈，最下面的我们称为栈底，最上面的我们称为栈顶，从栈顶拿出数据，通常称为出栈。栈一般是从高位地址向低位地址扩展，换句话说，栈底的内存地址是最高的，栈顶的是最小的。</p>
<p><font color="#0000FF">计算机系统主要使用栈来存放函数调用过程中需要的数据，包括参数、返回地址，函数内定义的局部变量也放在栈中。</font>计算机系统就如何在栈中存放这些数据，调用者和函数如何协作做了约定。返回值不太一样，它可能放在栈中，但它使用的栈和局部变量不完全一样，有的系统使用CPU内的一个存储器存储返回值，我们可以简单认为存在一个专门的返回值存储器。 main函数的相关数据放在栈的最下面，每调用一次函数，都会将相关函数的数据入栈，调用结束会出栈。</p>
<p>以上描述可能有点抽象，我们通过一个例子来说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"> <span class="number">4</span>         <span class="keyword">int</span> c = a + b;</span><br><span class="line"> <span class="number">5</span>         <span class="keyword">return</span> c;</span><br><span class="line"> <span class="number">6</span>     &#125;</span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="number">9</span>         <span class="keyword">int</span> d = Sum.sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="number">10</span>         System.out.println(d);</span><br><span class="line"><span class="number">11</span>     &#125;</span><br><span class="line"><span class="number">12</span> </span><br><span class="line"><span class="number">13</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这是一个简单的例子，main函数调用了sum函数，计算1和2的和，然后输出计算结果，从概念上，这是容易理解的，让我们从栈的角度来讨论下。</p>
<p>当程序在main函数调用Sum.sum之前，栈的情况大概是这样的：</p>
<p><img src="/2018/06/06/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86_p2.png" alt="img"></p>
<p>主要存放了两个变量args和d。在程序执行到Sum.sum的函数内部，准备返回之前，即第5行，栈的情况大概是这样的：</p>
<p><img src="/2018/06/06/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86_p3.png" alt="img"></p>
<p>我们解释下，在main函数调用Sum.sum时，首先将参数1和2入栈，然后将返回地址（也就是调用函数结束后要执行的指令地址）入栈，接着跳转到sum 函数，在sum函数内部，需要为局部变量c分配一个空间，而参数变量a和b则直接对应于入栈的数据1和2，在返回之前，返回值保存到了专门的返回值存储器 中。</p>
<p>在调用return后，程序会跳转到栈中保存的返回地址，即main的下一条指令地址，而sum函数相关的数据会出栈，从而又变回下面这样：</p>
<p><img src="/2018/06/06/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86_p4.png" alt="img"></p>
<p>main的下一条指令是根据函数返回值给变量d赋值，返回值从专门的返回值存储器中获得。</p>
<p>函数执行的基本原理，简单来说就是这样。但有一些需要介绍的点，我们讨论一下。</p>
<h3 id="变量生命周期"><a href="#变量生命周期" class="headerlink" title="变量生命周期"></a>变量生命周期</h3><p>定义一个变量就会分配一块内存，但我们并没有具体谈什么时候分配内存，具体分配在哪里，什么时候释放内存。</p>
<p>从以上关于栈的描述我们可以看出，<font color="#0000FF">函数中的参数和函数内定义的变量，都分配在栈中，这些变量只有在函数被调用的时候才分配，而且在调用结束后就被释放了。</font>但这个说法主要针对基本数据类型，接下来我们谈数组和对象。</p>
<h3 id="数组和对象"><a href="#数组和对象" class="headerlink" title="数组和对象"></a>数组和对象</h3><p>对于数组和对象类型，我们介绍过，它们都有两块内存，一块存放实际的内容，一块存放实际内容的地址，实际的内容空间一般不是分配在栈上的，而是分配在堆（也是内存的一部分，后续文章介绍）中，但存放地址的空间是分配在栈上的。</p>
<p>我们来看个例子，下面是代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayMax</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = min;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a&gt;max)&#123;</span><br><span class="line">                max = a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> ret = max(<span class="number">0</span>, arr);</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序也很简单，main函数新建了一个数组，然后调用函数max计算0和数组中元素的最大值，在程序执行到max函数的return语句之前的时候，内存中栈和堆的情况大概是这样的：</p>
<p><img src="/2018/06/06/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86_p5.png" alt="img"></p>
<p>对于数组arr，在栈中存放的是实际内容的地址0x1000，存放地址的栈空间会随着入栈分配，出栈释放，但存放实际内容的堆空间不受影响。</p>
<p>但说堆空间完全不受影响是不正确的，在这个例子中，当main函数执行结束，栈空间没有变量指向它的时候，Java系统会自动进行垃圾回收，从而释放这块空间。</p>
<h3 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h3><p> 我们再通过栈的角度来理解一下递归函数的调用过程，代码如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n*factorial(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = factorial(<span class="number">4</span>);</span><br><span class="line">    System.out.println(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在factorial第一次被调用的时候，n是4，在执行到 n<em>factorial(n-1)，即4</em>factorial(3)之前的时候，栈的情况大概是：</p>
<p><img src="/2018/06/06/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86_p6.png" alt="img"><br>注意返回值存储器是没有值的，在调用factorial(3)后，栈的情况变为了：</p>
<p><img src="/2018/06/06/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86_p7.png" alt="img"></p>
<p>栈的深度增加了，返回值存储器依然为空，就这样，每递归调用一次，栈的深度就增加一层，每次调用都会分配对应的参数和局部变量，也都会保存调用的返回地址，在调用到n等于0的时候，栈的情况是：</p>
<p>这个时候，终于有返回值了，我们将factorial简写为f。f(0)的返回值为1，f(0)返回到f(1)，f(1)执行1<em>f(0)，结果也是1，然 后返回到f(2)，f(2)执行2</em>f(1)，结果是2，然后接着返回到f(3)，f(3)执行3<em>f(2)，结果是6，然后返回到f(4)，执行 4</em>f(3)，结果是24。</p>
<p>以上就是<font color="#0000FF">递归函数的执行过程，函数代码虽然只有一份，但在执行的过程中，每调用一次，就会有一次入栈，生成一份不同的参数、局部变量和返回地址。</font></p>
<h3 id="函数调用成本"><a href="#函数调用成本" class="headerlink" title="函数调用成本"></a>函数调用成本</h3><p>从函数调用的过程我们可以看出，调用是有成本的，每一次调用都需要分配额外的栈空间用于存储参数、局部变量以及返回地址，需要进行额外的入栈和出栈操作。</p>
<p>在递归调用的情况下，如果递归的次数比较多，这个成本是比较可观的，所以，如果程序可以比较容易的改为别的方式，应该考虑别的方式。</p>
<p>另外，栈的空间不是无限的，一般正常调用都是没有问题的，但像上节介绍的例子，栈空间过深，系统就会抛出错误，java.lang.StackOverflowError，即栈溢出。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>函数是计算机程序的一种重要结构，通过函数来减少重复代码，分解复杂操作是计算机程序的一种重要思维方式。 </p>
<p>本文我们介绍了函数的基础概念，还有关于参数传递、返回值、重载、递归方面和调用实现机制上的一些细节 。 函数调用主要是通过栈来存储相关数据的，系统就函数调用者和函数如何使用栈做了约定，返回值我们简化认为是通过一个专门的返回值存储器存储的，我们主要从概念上介绍了其基本原理。 </p>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2018/06/10/Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/" title="Java异常体系以及应用" class="prev">PREV</a><a href="/2018/06/05/%E5%89%96%E6%9E%90String/" title="剖析String" class="next">NEXT</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "z8IRFulmWfMBxtW0H4j8jGUC-gzGzoHsz",
    appKey: "da7lA80m2TSYSJFxtyMFuFD6",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2016 - 2021 <a target="_blank">RedPig</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p> <span style="padding-right: 6px;">闽ICP备16007301号-2</span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/jquery-1.8.2.min.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/articleCatalog.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>