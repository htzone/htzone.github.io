<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> Java异常体系以及应用 · RedPig's Blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Java异常体系以及应用 - RedPig"><meta name="keywords"><meta name="author" content="RedPig"><link rel="short icon" href="/images/favicon.png"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="http://example.com/atom.xml" title="RedPig's Blog"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="RedPig's Blog" type="application/atom+xml">
</head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="目录" class="nav-list-link">目录</a></li><li class="nav-list-item"><a href="https://github.com/htzone" target="_blank" data-hover="项目" class="nav-list-link">项目</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">Java异常体系以及应用</h1><div class="post-info">2018-06-10</div><div class="post-content"><p>之前我们介绍的基本类型、类、接口、枚举都是在表示和操作数据，操作的过程中可能有很多出错的情况，出错的原因可能是多方面的，有的是不可控的内部原因，比如内存不够了、磁盘满了，有的是不可控的外部原因，比如网络连接有问题，更多的可能是程序的编程错误，比如引用变量未初始化就直接调用实例方法。</p>
<p>这些非正常情况在Java中统一被认为是异常，Java使用异常机制来统一处理，由于内容较多，我们分为两节来介绍，本节介绍异常的初步概念，以及异常类本身，下节主要介绍异常的处理。</p>
<p>我们先来通过一些例子认识一下异常。</p>
<h2 id="初始异常"><a href="#初始异常" class="headerlink" title="初始异常"></a>初始异常</h2><h3 id="NullPointerException-空指针异常"><a href="#NullPointerException-空指针异常" class="headerlink" title="NullPointerException (空指针异常)"></a>NullPointerException (空指针异常)</h3><p>我们来看段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        s.indexOf(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量s没有初始化就调用其实例方法indexOf，运行，屏幕输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException</span><br><span class="line">    at ExceptionTest.main(ExceptionTest.java:<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>输出是告诉我们：在ExceptionTest类的main函数中，代码第5行，出现了空指针异常(java.lang.NullPointerException)。</p>
<p>但，具体发生了什么呢？当执行s.indexOf(“a”)的时候，Java系统发现s的值为null，没有办法继续执行了，这时就启用异常处理机制，首先创建一个异常对象，这里是类NullPointerException的对象，然后查找看谁能处理这个异常，在示例代码中，没有代码能处理这个异常，Java就启用默认处理机制，那就是打印异常栈信息到屏幕，并退出程序。</p>
<p>异常栈信息就包括了从异常发生点到最上层调用者的轨迹，还包括行号，可以说，这个栈信息是分析异常最为重要的信息。</p>
<p>Java的默认异常处理机制是退出程序，异常发生点后的代码都不会执行，所以示例代码中最后一行System.out.println(“end”)不会执行。</p>
<h3 id="NumberFormatException-数字格式异常"><a href="#NumberFormatException-数字格式异常" class="headerlink" title="NumberFormatException (数字格式异常)"></a>NumberFormatException (数字格式异常)</h3><p>我们再来看一个例子，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入数字&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>args表示命令行参数，这段代码要求参数为一个数字，它通过Integer.parseInt将参数转换为一个整数，并输出这个整数。参数是用户输入的，我们没有办法强制用户输入什么，如果用户输的是数字，比如123，屏幕会输出123，但如果用户输的不是数字，比如abc，屏幕会输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NumberFormatException: For input string: &quot;abc&quot;</span><br><span class="line">    at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)</span><br><span class="line">    at java.lang.Integer.parseInt(Integer.java:492)</span><br><span class="line">    at java.lang.Integer.parseInt(Integer.java:527)</span><br><span class="line">    at ExceptionTest.main(ExceptionTest.java:7)</span><br></pre></td></tr></table></figure>

<p>出现了异常NumberFormatException。这个异常是怎么产生的呢？根据异常栈信息，我们看相关代码：</p>
<p>这是NumberFormatException类65行附近代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">64</span> <span class="function"><span class="keyword">static</span> NumberFormatException <span class="title">forInputString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="number">65</span>     <span class="keyword">return</span> <span class="keyword">new</span> NumberFormatException(<span class="string">&quot;For input string: \&quot;&quot;</span> + s + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line"><span class="number">66</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这是Integer类492行附近代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">490</span> digit = Character.digit(s.charAt(i++),radix);</span><br><span class="line"><span class="number">491</span> <span class="keyword">if</span> (digit &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">492</span>     <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line"><span class="number">493</span> &#125;</span><br><span class="line"><span class="number">494</span> <span class="keyword">if</span> (result &lt; multmin) &#123;</span><br><span class="line"><span class="number">495</span>     <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line"><span class="number">496</span> &#125;</span><br></pre></td></tr></table></figure>

<p>将这两处合为一行，主要代码就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(...)</span><br></pre></td></tr></table></figure>

<p>new NumberFormatException(…)是我们容易理解的，就是创建了一个类的对象，只是这个类是一个异常类。throw是什么意思呢？就是抛出异常，它会触发Java的异常处理机制。在之前的空指针异常中，我们没有看到throw的代码，可以认为throw是由Java虚拟机自己实现的。</p>
<p>throw关键字可以与return关键字进行对比，return代表正常退出，throw代表异常退出，return的返回位置是确定的，就是上一级调用者，而throw后执行哪行代码则经常是不确定的，由异常处理机制动态确定。</p>
<p>异常处理机制会从当前函数开始查找看谁”捕获”了这个异常，当前函数没有就查看上一层，直到主函数，如果主函数也没有，就使用默认机制，即输出异常栈信息并退出，这正是我们在屏幕输出中看到的。</p>
<p>对于屏幕输出中的异常栈信息，程序员是可以理解的，但普通用户无法理解，也不知道该怎么办，我们需要给用户一个更为友好的信息，告诉用户，他应该输入的是数字，要做到这一点，我们需要自己”捕获”异常。</p>
<p>“捕获”是指使用try/catch关键字，我们看捕获异常后的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入数字&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">            System.out.println(num);    </span><br><span class="line">        &#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;参数&quot;</span>+args[<span class="number">0</span>]</span><br><span class="line">                    +<span class="string">&quot;不是有效的数字，请输入数字&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用try/catch捕获并处理了异常，try后面的大括号{}内包含可能抛出异常的代码，括号后的catch语句包含能捕获的异常和处理代码，catch后面括号内是异常信息，包括异常类型和变量名，这里是NumberFormatException e，通过它可以获取更多异常信息，大括号{}内是处理代码，这里输出了一个更为友好的提示信息。</p>
<p>捕获异常后，程序就不会异常退出了，但try语句内异常点之后的其他代码就不会执行了，执行完catch内的语句后，程序会继续执行catch大括号外的代码。</p>
<p>这样，我们就对异常有了一个初步的了解，异常是相对于return的一种退出机制，可以由系统触发，也可以由程序通过throw语句触发，异常可以通过try/catch语句进行捕获并处理，如果没有捕获，则会导致程序退出并输出异常栈信息。异常有不同的类型，接下来，我们来认识一下。</p>
<h2 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h2><h3 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h3><p>NullPointerException和NumberFormatException都是异常类，所有异常类都有一个共同的父类Throwable，它有4个public构造方法：</p>
<ol>
<li>public Throwable()</li>
<li>public Throwable(String message)</li>
<li>public Throwable(String message, Throwable cause)</li>
<li>public Throwable(Throwable cause) </li>
</ol>
<p>有两个主要参数，一个是message，表示异常消息，另一个是cause，表示触发该异常的其他异常。异常可以形成一个异常链，上层的异常由底层异常触发，cause表示底层异常。</p>
<p>Throwable还有一个public方法用于设置cause：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Throwable <span class="title">initCause</span><span class="params">(Throwable cause)</span></span></span><br></pre></td></tr></table></figure>

<p>Throwable的某些子类没有带cause参数的构造方法，就可以通过这个方法来设置，这个方法最多只能被调用一次。</p>
<p>所有构造方法中都有一句重要的函数调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fillInStackTrace();</span><br></pre></td></tr></table></figure>

<p>它会将异常栈信息保存下来，这是我们能看到异常栈的关键。</p>
<p>Throwable有一些常用方法用于获取异常信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStackTrace</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>打印异常栈信息到标准错误输出流，它还有两个重载的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStackTrace</span><span class="params">(PrintStream s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStackTrace</span><span class="params">(PrintWriter s)</span></span></span><br></pre></td></tr></table></figure>

<p>打印栈信息到指定的流，关于PrintStream和PrintWriter我们后续文章介绍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Throwable <span class="title">getCause</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>获取设置的异常message和cause</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StackTraceElement[] getStackTrace()</span><br></pre></td></tr></table></figure>

<p>获取异常栈每一层的信息，每个StackTraceElement包括文件名、类名、函数名、行号等信息。</p>
<h2 id="异常类体系"><a href="#异常类体系" class="headerlink" title="异常类体系"></a>异常类体系</h2><p>以Throwable为根，Java API中定义了非常多的异常类，表示各种类型的异常，部分类示意如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/924211/201607/924211-20160707195250233-1530995915.jpg" alt="img"></p>
<p>Throwable是所有异常的基类，它有两个子类Error和Exception。</p>
<p>Error表示系统错误或资源耗尽，由Java系统自己使用，应用程序不应抛出和处理，比如图中列出的虚拟机错误(VirtualMacheError)及其子类内存溢出错误(OutOfMemoryError)和栈溢出错误(StackOverflowError)。</p>
<p>Exception表示应用程序错误，它有很多子类，应用程序也可以通过继承Exception或其子类创建自定义异常，图中列出了三个直接子类：IOException(输入输出I/O异常)，SQLException(数据库SQL异常)，RuntimeException(运行时异常)。</p>
<p>RuntimeException(运行时异常)比较特殊，它的名字有点误导，因为其他异常也是运行时产生的，它表示的实际含义是unchecked exception (未受检异常)，相对而言，Exception的其他子类和Exception自身则是checked exception (受检异常)，Error及其子类也是unchecked exception。</p>
<p>checked还是unchecked，区别在于Java如何处理这两种异常，对于checked异常，Java会强制要求程序员进行处理，否则会有编译错误，而对于unchecked异常则没有这个要求。下节我们会进一步解释。</p>
<p>RuntimeException也有很多子类，下表列出了其中常见的一些：</p>
<table>
<thead>
<tr>
<th>异常</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NullPointerException</td>
<td>空指针异常</td>
</tr>
<tr>
<td>IllegalStateException</td>
<td>非法状态</td>
</tr>
<tr>
<td>ClassCastException</td>
<td>非法强制类型转换</td>
</tr>
<tr>
<td>IllegalArgumentException</td>
<td>参数错误</td>
</tr>
<tr>
<td>NumberFormatException</td>
<td>数字格式错误</td>
</tr>
<tr>
<td>IndexOutOfBoundsException</td>
<td>索引越界</td>
</tr>
<tr>
<td>ArrayIndexOutOfBoundsException</td>
<td>数组索引越界</td>
</tr>
<tr>
<td>StringIndexOutOfBoundsException</td>
<td>字符串索引越界</td>
</tr>
</tbody></table>
<p>这么多不同的异常类其实并没有比Throwable这个基类多多少属性和方法，大部分类在继承父类后只是定义了几个构造方法，这些构造方法也只是调用了父类的构造方法，并没有额外的操作。</p>
<p>那为什么定义这么多不同的类呢？主要是为了名字不同，异常类的名字本身就代表了异常的关键信息，无论是抛出还是捕获异常时，使用合适的名字都有助于代码的可读性和可维护性。</p>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>除了Java API中定义的异常类，我们也可以自己定义异常类，一般通过继承Exception或者它的某个子类，如果父类是RuntimeException或它的某个子类，则自定义异常也是unchecked exception，如果是Exception或Exception的其他子类，则自定义异常是checked exception。</p>
<p>我们通过继承Exception来定义一个异常，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppException</span><span class="params">(String message,</span></span></span><br><span class="line"><span class="function"><span class="params">            Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和很多其他异常类一样，我们没有定义额外的属性和代码，只是继承了Exception，定义了构造方法并调用了父类的构造方法。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节，我们通过两个例子对异常做了基本介绍，介绍了try/catch和throw关键字及其含义，同时介绍了Throwable以及以它为根的异常类体系。</p>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2018/06/05/%E5%89%96%E6%9E%90String/" title="剖析String" class="next">NEXT</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "z8IRFulmWfMBxtW0H4j8jGUC-gzGzoHsz",
    appKey: "da7lA80m2TSYSJFxtyMFuFD6",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2016 - 2021 <a target="_blank">RedPig</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p> <span style="padding-right: 6px;">闽ICP备16007301号-2</span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/jquery-1.8.2.min.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/articleCatalog.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>